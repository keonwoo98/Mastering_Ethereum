# **Chapter 6. 트랜잭션**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

트랜잭션은 외부 소유 계정(EOA)에 의해 서명된 메시지인데, 이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록된다. 이 기본 정의는 놀라울 정도로 매력적인 의미를 담고 있다. 다른 관점에서 바라보면, 트랜잭션은 EVM에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이라는 것이다. 이더리움은 글로벌 싱글톤 상태 머신이며, 트랜잭션은 이 상태 머신을 움직여서 상태를 변경할 수 있도록 만든다. 컨트랙트는 독자적으로 실행되지 않는다. 또한 이더리움도 자율적으로 실행되지 않는다. 모든 것은 트랜잭션으로부터 시작된다.

## **1. 트랜잭션 구조**

먼저 이더리움 네트워크에서 시리얼라이즈(serialize)되어 전송되는 트랜잭션의 기본 구조를 살펴보자. 시리얼라이즈된 트랜잭션을 수신하는 각 클라이언트와 애플리케이션은 자체 내부 데이터 구조를 사용하여 트랜잭션을 메모리에 저장하며, 네트워크에서 시리얼라이즈된 트랜잭션 자체에는 존재하지 않는 메타데이터가 포함되어 있다. 네트워크 시리얼라이제이션은 트랜잭션의 유일한 표준 형식이다.

트랜잭션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지다.

**논스(nonce)**
* 발신 EOA에 의해 발행되어 메시지 재사용을 방지하는 데 사용되는 일련번호

**가스 가격(gas price)**
* 발신자가 지급하는 가스의 가격(웨이)

**가스 한도(gas limit)**
* 이 트랜잭션을 위해 구입할 가스의 최대량

**수신자(recipient)**
* 목적지 이더리움 주소

**값(value)**
* 목적지에 보낼 이더의 양

**데이터(data)**
* 가변 길이 바이너리 데이터 페이로드

**v, r, s**
* EOA의 ECDSA 디지털 서명의 세 가지 구성요소

트랜잭션 메시지의 구조는 이더리움에서 간단하고 완벽한 바이트 시리얼라이제이션을 위해 특별히 만들어진 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 시리얼라이즈된다. 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디안 정수로 인코딩된다.

명확성을 위해 여기에 필드 라벨(수신자, 가스 한도 등)이 표시되지만, 이 필드 값들은 RLP로 인코딩된 필드 값이 들어 있는, 시리얼라이즈된 트랜잭션 데이터의 일부가 아니라는 점을 유의하자. 일반적으로 RLP는 필드 구분자 또는 라벨을 포함하지 않는다. RLP의 길이 접두어는 각 필드의 길이를 식별하는 데 사용된다. 따라서 정의된 길이를 초과하는 것은 구조상 다음 필드에 속한다.

이것이 실제 전송되는 트랜잭션 구조인데, 내부 정보를 보여주거나 사용자 인터페이스를 시각화하기 위해서는 트랜잭션 구조 이외에도 트랜잭션이나 블록체인에서 파생된 추가 정보를 사용한다.

예를 들어 발신자 EOA를 식별하는 주소에 '발신자(from)' 데이터가 없는데, 이것은 EOA의 공개키를 ECDSA 서명의 v, r, s 구성요소로부터 알아낼 수 있으며, 이는 공개키를 통해 주소를 알아낼 수 있음을 의미한다. 즉, 주소는 공개키에서 파생될 수 있다. '발신자' 필드가 표시된 트랜잭션이라면, 시각화하는 데 사용된 소프트웨어에 의해 추가된 것이다. 클라이언트 소프트웨어에 의해 트랜잭션에 자주 추가되는 다른 메타데이터는 블록 번호(채굴되고 블록체인에 포함된)와 트랜잭션 ID(계산된 해시)를 포함한다. 다시 말하면, 이 데이터는 트랜잭션에서 파생되며 트랜잭션 메시지 자체의 일부가 아니다.

## **2. 트랜잭션 논스**

논스(nonce)는 트랜잭션에서 가장 중요하고 이해하기 어려운 구성요소 중 하나다. 황서에서는 다음과 같이 정의한다.

논스 : 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계정의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값

엄밀히 말하면, 논스는 발신 주소의 속성이며 단지 발신 주소의 컨트랙트 안에서만 의미를 갖는다. 그러나 논스는 명시적으로 블록체인 계정 상태에 저장되지 않고, 해당 주소에서 발생한 확인된 트랜잭션 건수를 세어서 동적으로 계산되는 값이다.

아래의 두 가지 상황을 통해서 트랜잭션을 세는 논스의 중요성에 대해 알아보자. 하나는 트랜잭션 생성 순서대로 포함된다는 점에서 생기는 사용성상의 기능(usability feature)이며, 다른 하나는 트랜잭션 복제 방지라는 주요 기능에서의 측면이다. 이들 각각에 대한 예제 시나리오를 살펴보자.

1. 두 가지 트랜잭션을 한다고 생각해보자. 하나는 6개의 이더를 지급해야 하는 중요한 트랜잭션이고, 또 하나는 8개의 이더를 지급해야 하는 트랜잭션이다. 먼저 6이더 트랜잭션에 서명하고 전파하는 것이 더 중요하기 때문에 이 트랜잭션을 먼저 한 뒤, 두 번째 8이 더 트랜잭션에 서명하고 전파한다. 안타깝게도 계정에 이더가 10개밖에 없다는 사실을 간과했으므로, 네트워크에서 트랜잭션을 둘 다 받을 수 없어서 그중 하나는 실패한다. 더 중요한 6이더 트랜잭션을 먼저 보냈기 때문에 여러분은 당연히 앞선 트랜잭션은 성공하고 8이더 트랜잭션은 거부될 것으로 생각한다. 하지만 이더리움처럼 탈중앙화된 시스템에서 노드는 어떤 순서로든 트랜잭션을 수신할 수 있다. 특정 노드가 다른 노드보다 특정한 트랜잭션을 먼저 받을 것이라는 보장은 없다. 따라서 어떤 노드는 6이더 트랜잭션을 먼저 수신하고, 또 어떤 노드는 8이더 트랜잭션을 먼저 수신한다. 논스가 없다면 어느 것이 받아들여지고 어떤 것이 거부될지는 알 수 없다. 그러나 논스가 포함된 상태에서 보낸 첫 번째 트랜잭션은 논스 값이 예를 들어서 3이라고 하자. 8이더 트랜잭션은 다음 논스 값(즉, 4)을 갖는다. 그러면 0부터 3까지의 논스가 있는 트랜잭션이 처리될 때까지 해당 트랜잭션은 무시된다(8이더 트랜잭션이 먼저 수신되더라도).
2. 이제 여러분의 계정에 100이더가 있다고 가정해보자. 여러분이 정말로 사고싶어 하는 mcguffin-widget에 대한 지급을 이더로 받을 판매자를 찾는다. 그들에게 2이더를 보내면 그들은 mcguffin-widget을 보낸다. 2이더를 지급하기 위해, 여러분의 계정에서 그들의 계정으로 2이더를 전송하는 트랜잭션에 서명한 다음, 트랜잭션을 이더리움 네트워크로 전파하여 검증한 후에 블록체인에 저장한다. 이제 논스 값 없이 2이더를 동일한 주소로 보내는 두 번째 트랜잭션은 첫 번째 트랜잭션과 정확히 동일하게 보인다. 즉, 이더리움 네트워크에서 트랜잭션을 보는 사람(수신자 또는 적을 포함하여 모든 사람을 의미함)은 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 방식으로 여러분의 이더가 소진될 때까지 계속 트랜잭션을 반복해서 '재실행(reply)'할 수 있다. 그러나 트랜잭션 데이터에 포함된 논스 값을 사용하면 동일한 수신자 주소에 동일한 양의 이더를 여러 번 보내는 경우에도 각각의 개별 트랜잭션은 고유하다. 따라서 트랜잭션의 일부로 논스를 증가시킴으로써 누군가가 지급한 금액을 '복제(duplicate)'하는 행위를 막을 수 있다.

요약하면, 비트코인 프로토콜의 '미사용 트랜잭션 아웃풋(Unspent Transaction Output, UTXO)' 메커니즘과 달리, `계정 기반(account-based)` 프로토콜은 논스를 사용하는 것이 실제로 필수적임을 유의해야 한다.

### **2-1. 논스 추적**

실질적으로 논스는 각 계정에서 발생한 확인된(즉, 체인상의) 트랜잭션 건수에 대한 최신 통계다. 논스 값을 알아내려면, 예를 들어 web3 인터페이스를 통해 블록체인을 조회해야 한다. 메타마스크를 실행 중인 상태에서 브라우저에게 자바스크립트 콘솔을 열거나 truffle console 명령을 사용하여 자바스크립트 web3 라이브러리에 접근한 후 다음을 입력하라.

```
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
```

> 논스는 0부터 시작하는 카운터로, 첫 번째 트랜잭션의 논스는 0이다. 이 예에서 트랜잭션 건수는 40으로, 0부터 39까지의 논스가 사용되었다. 다음 트랜잭션의 논스는 40이어야 한다.

여러분의 지갑은 그 지갑에서 관리하는 각 주소에 대한 논스를 추적한다. 하나의 지갑에서만 트랜잭션을 만드는 경우는 논스 추적이 매우 간단하다. 여러분이 자신의 지갑 소프트웨어 또는 트랜잭션을 발생시키는 어떤 애플리케이션을 작성한다고 하자. 논스를 어떻게 추적할 것인가?

새 트랜잭션을 만들 때 시퀀스상 다음 차례 논스 값을 부여한다. 그러나 이것이 컨펌될 때까지는 getTransactionCount 합계에 포함되지 않는다.

> 대기 중인 트랜잭션 건수 계산을 위해 getTransactionCount 함수를 사용할 때는 주의해야한다. 연속해서 몇 개의 트랜잭션을 보내는 경우 문제가 발생할 수 있기 때문이다.

예제를 살펴보자.

```
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
40
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
```

보다시피, 우리가 보낸 첫 번째 트랜잭션은 트랜잭션 건수를 41로 늘렸고 현재 상태는 보류 중이다. 그러나 우리가 연속적으로 세 번 더 트랜잭션을 보냈을 때 getTransactionCount 호출은 3개의 트랜잭션을 세지 않았다. 여러분은 멤풀(mempool)에 보류 중인 트랜잭션 3개가 있을 것이라고 생각하지만, 오직 하나의 트랜잭션만 대기 중이다. 네트워크 통신이 완료될 때까지 몇 초를 기다린 후에 getTransactionCount를 호출하면 이번에는 예상했던 숫자를 반환해 줄 것이다. 하지만 이것이 완료되기 전까지는 다수의 트랜잭션이 대기 중임에도 불구하고 이를 확인할 수 없다.

트랜잭션을 구성하는 애플리케이션을 만들 때 대기 중인 트랜잭션들을 확인하기 위해 getTransactionCount에 의존할 수 없다. 대기 중인 트랜잭션 개수와 확인된 트랜잭션 개수가 동일할 때만(미해결 트랜잭션이 모두 확인됨) getTransactionCount의 출력을 신뢰할 수 있고 논스 카운터를 시작할 수 있다. 그런 다음 각 트랜잭션이 확인될 때까지 애플리케이션의 논스를 추적하자.

패리티(Parity)의 JSON RPC 인터페이스는 트랜잭션에서 사용해야 하는 다음 논스를 반환하는 parity_nextNonce 함수를 제공한다. parity_nextNonce 함수는 각각의 트랜잭션을 확인하지 않고 빠르게 연속적으로 만들더라도 논스를 올바르게 계산한다.

```
$ curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545

{"jsonrpc":"2.0","result":"0x32","id":1}
```

> 패리티에는 JSON RPC 인터페이스에 접근하기 위한 웹 콘솔이 있지만, 여기서는 커맨드 라인 HTTP 클라이언트를 사용하여 접근한다.

### **2-2. 논스의 간격, 중복 논스 확인**

트랜잭션을 프로그램을 통해서 생성하는 경우, 특히 여러 독립 프로세스에서 동시에 트랜잭션을 생성하는 경우에는 논스를 추적하는 것이 중요하다.

이더리움 네트워크는 논스에 따라 트랜잭션을 순차적으로 처리한다. 즉, 논스가 0인 트랜잭션을 전송한 다음 논스가 2인 트랜잭션을 전송하면, 두 번째 트랜잭션은 어떤 블록에도 포함되지 않는다. 이더리움 네트워크가 누락된 논스가 나타날 때까지 기다리는 동안 두 번째 트랜잭션은 멤풀(mempool)에 저장된다. 모든 노드는 누락된 논스가 단순히 지연되었고 논스가 2인 트랜잭션은 순서가 맞지 않게 수신되었다고 가정한다.

그런 다음 논스가 1인 누락된 트랜잭션을 전송하면, 두 트랜잭션(논스 1과 2)이 처리되고 블록에 포함된다(물론 유효한 경우). 갭(gap)을 메우면 네트워크는 멤풀에서 보유한 순서가 잘못된 트랜잭션을 처리할 수 있다.

