# **Chapter 6. 트랜잭션**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

트랜잭션은 외부 소유 계정(EOA)에 의해 서명된 메시지인데, 이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록된다. 이 기본 정의는 놀라울 정도로 매력적인 의미를 담고 있다. 다른 관점에서 바라보면, 트랜잭션은 EVM에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이라는 것이다. 이더리움은 글로벌 싱글톤 상태 머신이며, 트랜잭션은 이 상태 머신을 움직여서 상태를 변경할 수 있도록 만든다. 컨트랙트는 독자적으로 실행되지 않는다. 또한 이더리움도 자율적으로 실행되지 않는다. 모든 것은 트랜잭션으로부터 시작된다.

## **1. 트랜잭션 구조**

먼저 이더리움 네트워크에서 시리얼라이즈(serialize)되어 전송되는 트랜잭션의 기본 구조를 살펴보자. 시리얼라이즈된 트랜잭션을 수신하는 각 클라이언트와 애플리케이션은 자체 내부 데이터 구조를 사용하여 트랜잭션을 메모리에 저장하며, 네트워크에서 시리얼라이즈된 트랜잭션 자체에는 존재하지 않는 메타데이터가 포함되어 있다. 네트워크 시리얼라이제이션은 트랜잭션의 유일한 표준 형식이다.

트랜잭션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지다.

**논스(nonce)**
* 발신 EOA에 의해 발행되어 메시지 재사용을 방지하는 데 사용되는 일련번호

**가스 가격(gas price)**
* 발신자가 지급하는 가스의 가격(웨이)

**가스 한도(gas limit)**
* 이 트랜잭션을 위해 구입할 가스의 최대량

**수신자(recipient)**
* 목적지 이더리움 주소

**값(value)**
* 목적지에 보낼 이더의 양

**데이터(data)**
* 가변 길이 바이너리 데이터 페이로드

**v, r, s**
* EOA의 ECDSA 디지털 서명의 세 가지 구성요소

트랜잭션 메시지의 구조는 이더리움에서 간단하고 완벽한 바이트 시리얼라이제이션을 위해 특별히 만들어진 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 시리얼라이즈된다. 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디안 정수로 인코딩된다.

명확성을 위해 여기에 필드 라벨(수신자, 가스 한도 등)이 표시되지만, 이 필드 값들은 RLP로 인코딩된 필드 값이 들어 있는, 시리얼라이즈된 트랜잭션 데이터의 일부가 아니라는 점을 유의하자. 일반적으로 RLP는 필드 구분자 또는 라벨을 포함하지 않는다. RLP의 길이 접두어는 각 필드의 길이를 식별하는 데 사용된다. 따라서 정의된 길이를 초과하는 것은 구조상 다음 필드에 속한다.

이것이 실제 전송되는 트랜잭션 구조인데, 내부 정보를 보여주거나 사용자 인터페이스를 시각화하기 위해서는 트랜잭션 구조 이외에도 트랜잭션이나 블록체인에서 파생된 추가 정보를 사용한다.

예를 들어 발신자 EOA를 식별하는 주소에 '발신자(from)' 데이터가 없는데, 이것은 EOA의 공개키를 ECDSA 서명의 v, r, s 구성요소로부터 알아낼 수 있으며, 이는 공개키를 통해 주소를 알아낼 수 있음을 의미한다. 즉, 주소는 공개키에서 파생될 수 있다. '발신자' 필드가 표시된 트랜잭션이라면, 시각화하는 데 사용된 소프트웨어에 의해 추가된 것이다. 클라이언트 소프트웨어에 의해 트랜잭션에 자주 추가되는 다른 메타데이터는 블록 번호(채굴되고 블록체인에 포함된)와 트랜잭션 ID(계산된 해시)를 포함한다. 다시 말하면, 이 데이터는 트랜잭션에서 파생되며 트랜잭션 메시지 자체의 일부가 아니다.

## **2. 트랜잭션 논스**

논스(nonce)는 트랜잭션에서 가장 중요하고 이해하기 어려운 구성요소 중 하나다. 황서에서는 다음과 같이 정의한다.

논스 : 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계정의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값

엄밀히 말하면, 논스는 발신 주소의 속성이며 단지 발신 주소의 컨트랙트 안에서만 의미를 갖는다. 그러나 논스는 명시적으로 블록체인 계정 상태에 저장되지 않고, 해당 주소에서 발생한 확인된 트랜잭션 건수를 세어서 동적으로 계산되는 값이다.

아래의 두 가지 상황을 통해서 트랜잭션을 세는 논스의 중요성에 대해 알아보자. 하나는 트랜잭션 생성 순서대로 포함된다는 점에서 생기는 사용성상의 기능(usability feature)이며, 다른 하나는 트랜잭션 복제 방지라는 주요 기능에서의 측면이다. 이들 각각에 대한 예제 시나리오를 살펴보자.

1. 두 가지 트랜잭션을 한다고 생각해보자. 하나는 6개의 이더를 지급해야 하는 중요한 트랜잭션이고, 또 하나는 8개의 이더를 지급해야 하는 트랜잭션이다. 먼저 6이더 트랜잭션에 서명하고 전파하는 것이 더 중요하기 때문에 이 트랜잭션을 먼저 한 뒤, 두 번째 8이 더 트랜잭션에 서명하고 전파한다. 안타깝게도 계정에 이더가 10개밖에 없다는 사실을 간과했으므로, 네트워크에서 트랜잭션을 둘 다 받을 수 없어서 그중 하나는 실패한다. 더 중요한 6이더 트랜잭션을 먼저 보냈기 때문에 여러분은 당연히 앞선 트랜잭션은 성공하고 8이더 트랜잭션은 거부될 것으로 생각한다. 하지만 이더리움처럼 탈중앙화된 시스템에서 노드는 어떤 순서로든 트랜잭션을 수신할 수 있다. 특정 노드가 다른 노드보다 특정한 트랜잭션을 먼저 받을 것이라는 보장은 없다. 따라서 어떤 노드는 6이더 트랜잭션을 먼저 수신하고, 또 어떤 노드는 8이더 트랜잭션을 먼저 수신한다. 논스가 없다면 어느 것이 받아들여지고 어떤 것이 거부될지는 알 수 없다. 그러나 논스가 포함된 상태에서 보낸 첫 번째 트랜잭션은 논스 값이 예를 들어서 3이라고 하자. 8이더 트랜잭션은 다음 논스 값(즉, 4)을 갖는다. 그러면 0부터 3까지의 논스가 있는 트랜잭션이 처리될 때까지 해당 트랜잭션은 무시된다(8이더 트랜잭션이 먼저 수신되더라도).
2. 이제 여러분의 계정에 100이더가 있다고 가정해보자. 여러분이 정말로 사고싶어 하는 mcguffin-widget에 대한 지급을 이더로 받을 판매자를 찾는다. 그들에게 2이더를 보내면 그들은 mcguffin-widget을 보낸다. 2이더를 지급하기 위해, 여러분의 계정에서 그들의 계정으로 2이더를 전송하는 트랜잭션에 서명한 다음, 트랜잭션을 이더리움 네트워크로 전파하여 검증한 후에 블록체인에 저장한다. 이제 논스 값 없이 2이더를 동일한 주소로 보내는 두 번째 트랜잭션은 첫 번째 트랜잭션과 정확히 동일하게 보인다. 즉, 이더리움 네트워크에서 트랜잭션을 보는 사람(수신자 또는 적을 포함하여 모든 사람을 의미함)은 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 방식으로 여러분의 이더가 소진될 때까지 계속 트랜잭션을 반복해서 '재실행(reply)'할 수 있다. 그러나 트랜잭션 데이터에 포함된 논스 값을 사용하면 동일한 수신자 주소에 동일한 양의 이더를 여러 번 보내는 경우에도 각각의 개별 트랜잭션은 고유하다. 따라서 트랜잭션의 일부로 논스를 증가시킴으로써 누군가가 지급한 금액을 '복제(duplicate)'하는 행위를 막을 수 있다.

요약하면, 비트코인 프로토콜의 '미사용 트랜잭션 아웃풋(Unspent Transaction Output, UTXO)' 메커니즘과 달리, `계정 기반(account-based)` 프로토콜은 논스를 사용하는 것이 실제로 필수적임을 유의해야 한다.

### **2-1. 논스 추적**

실질적으로 논스는 각 계정에서 발생한 확인된(즉, 체인상의) 트랜잭션 건수에 대한 최신 통계다. 논스 값을 알아내려면, 예를 들어 web3 인터페이스를 통해 블록체인을 조회해야 한다. 메타마스크를 실행 중인 상태에서 브라우저에게 자바스크립트 콘솔을 열거나 truffle console 명령을 사용하여 자바스크립트 web3 라이브러리에 접근한 후 다음을 입력하라.

```
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
```

> 논스는 0부터 시작하는 카운터로, 첫 번째 트랜잭션의 논스는 0이다. 이 예에서 트랜잭션 건수는 40으로, 0부터 39까지의 논스가 사용되었다. 다음 트랜잭션의 논스는 40이어야 한다.

여러분의 지갑은 그 지갑에서 관리하는 각 주소에 대한 논스를 추적한다. 하나의 지갑에서만 트랜잭션을 만드는 경우는 논스 추적이 매우 간단하다. 여러분이 자신의 지갑 소프트웨어 또는 트랜잭션을 발생시키는 어떤 애플리케이션을 작성한다고 하자. 논스를 어떻게 추적할 것인가?

새 트랜잭션을 만들 때 시퀀스상 다음 차례 논스 값을 부여한다. 그러나 이것이 컨펌될 때까지는 getTransactionCount 합계에 포함되지 않는다.

> 대기 중인 트랜잭션 건수 계산을 위해 getTransactionCount 함수를 사용할 때는 주의해야한다. 연속해서 몇 개의 트랜잭션을 보내는 경우 문제가 발생할 수 있기 때문이다.

예제를 살펴보자.

```
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
40
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
```

보다시피, 우리가 보낸 첫 번째 트랜잭션은 트랜잭션 건수를 41로 늘렸고 현재 상태는 보류 중이다. 그러나 우리가 연속적으로 세 번 더 트랜잭션을 보냈을 때 getTransactionCount 호출은 3개의 트랜잭션을 세지 않았다. 여러분은 멤풀(mempool)에 보류 중인 트랜잭션 3개가 있을 것이라고 생각하지만, 오직 하나의 트랜잭션만 대기 중이다. 네트워크 통신이 완료될 때까지 몇 초를 기다린 후에 getTransactionCount를 호출하면 이번에는 예상했던 숫자를 반환해 줄 것이다. 하지만 이것이 완료되기 전까지는 다수의 트랜잭션이 대기 중임에도 불구하고 이를 확인할 수 없다.

트랜잭션을 구성하는 애플리케이션을 만들 때 대기 중인 트랜잭션들을 확인하기 위해 getTransactionCount에 의존할 수 없다. 대기 중인 트랜잭션 개수와 확인된 트랜잭션 개수가 동일할 때만(미해결 트랜잭션이 모두 확인됨) getTransactionCount의 출력을 신뢰할 수 있고 논스 카운터를 시작할 수 있다. 그런 다음 각 트랜잭션이 확인될 때까지 애플리케이션의 논스를 추적하자.

패리티(Parity)의 JSON RPC 인터페이스는 트랜잭션에서 사용해야 하는 다음 논스를 반환하는 parity_nextNonce 함수를 제공한다. parity_nextNonce 함수는 각각의 트랜잭션을 확인하지 않고 빠르게 연속적으로 만들더라도 논스를 올바르게 계산한다.

```
$ curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545

{"jsonrpc":"2.0","result":"0x32","id":1}
```

> 패리티에는 JSON RPC 인터페이스에 접근하기 위한 웹 콘솔이 있지만, 여기서는 커맨드 라인 HTTP 클라이언트를 사용하여 접근한다.

### **2-2. 논스의 간격, 중복 논스 확인**

트랜잭션을 프로그램을 통해서 생성하는 경우, 특히 여러 독립 프로세스에서 동시에 트랜잭션을 생성하는 경우에는 논스를 추적하는 것이 중요하다.

이더리움 네트워크는 논스에 따라 트랜잭션을 순차적으로 처리한다. 즉, 논스가 0인 트랜잭션을 전송한 다음 논스가 2인 트랜잭션을 전송하면, 두 번째 트랜잭션은 어떤 블록에도 포함되지 않는다. 이더리움 네트워크가 누락된 논스가 나타날 때까지 기다리는 동안 두 번째 트랜잭션은 멤풀(mempool)에 저장된다. 모든 노드는 누락된 논스가 단순히 지연되었고 논스가 2인 트랜잭션은 순서가 맞지 않게 수신되었다고 가정한다.

그런 다음 논스가 1인 누락된 트랜잭션을 전송하면, 두 트랜잭션(논스 1과 2)이 처리되고 블록에 포함된다(물론 유효한 경우). 갭(gap)을 메우면 네트워크는 멤풀에서 보유한 순서가 잘못된 트랜잭션을 처리할 수 있다.

즉, 여러 트랜잭션을 순서대로 생성하고 그중 하나가 공식적으로 모든 블록에 포함되지 않으면 이후의 모든 트랜잭션이 '멈추고' 누락된 논스를 기다린다. 유효하지 않거나 가스가 모자란 트랜잭션은 논스 시퀀스에 의도치 않게 '갭'을 만들 수 있다. 다시 트랜잭션이 계속되게 하려면 누락된 논스가 있는 유효한 트랜잭션을 전송해야 한다. '누락'된 논스가 있는 트랜잭션이 네트워크에 의해 유효성이 검증되면, 이후의 논스가 있는 모든 브로드캐스트된 트랜잭션이 차례대로 유효해진다는 점도 똑같이 염두에 두어야 한다. 트랜잭션을 '회수(recall)'하는 것은 불가능하다.

반면, 예를 들어 논스가 같지만 수신자나 값이 다른 2개의 트랜잭션을 전송하는 것과 같은 논스의 중복이 일어나면, 그중 하나가 확정되고 하나는 거부된다. 어떤 트랜잭션이 확정되는지는 그 트랜잭션이 첫 유효에 도달하는 순서에 따라 결정된다. 즉, 이는 무작위적이다.

보다시피 논스를 추적하는 것은 필요하며, 애플리케이션이 해당 프로세스를 올바르게 관리하지 않으면 문제가 발생할 수 있다. 불행하게도, 이것을 동시에 수행하려는 경우 상황이 더 어려워진다.

### **2-3. 동시 실행, 트랜잭션 생성 및 논스**

동시 실행은 컴퓨터 과학이 다루어야 하는 복잡한 문제이며, 때때로 예상치 못하게 발생할 수도 있는데, 특히 이더리움처럼 탈중앙화되어 있고 분산되어 있는 실시간 시스템에서는 더욱 그러하다.

간단히 말해, 동시 실행 문제는 여러 독립 시스템에 의한 동시적인 계산이 있는 경우다. 이들은 동일한 프로그램(예: 멀티스레딩), 동일한 CPU(예: 멀티프로세싱) 또는 다른 컴퓨터(즉, 분산 시스템)에 있을 수 있다. 이더리움은 정의상 작업(노드, 클라이언트, 댑)의 동시 실행을 허용하지만 합의를 통해 싱글톤 상태를 강제하는 시스템이다.

이제 동일한 주소에서 트랜잭션을 생성하는 여러 개의 독립적인 지갑 애플리케이션이 있다고 가정해 보자. 이러한 상황의 한 예가 거래소의 핫 월렛(hot wallet, 키가 온라인에 저장되지 않는 cold wallet과 달리 키가 온라인에 저장된 지갑)에서의 출금이다. 이상적으로는 병목 현상이나 단일 실패 지점이 생기지 않도록 2대 이상의 컴퓨터가 출금 작업을 처리하도록 하는 것이 좋다. 그러나 이것은 문제가 될 수 있다. 둘 이상의 컴퓨터에서 출금을 수행하면 동시 실행 문제가 발생할 수 있다. 물론, 논스를 선택하는 것도 중요한 문제다. 동일한 핫 월렛 계정에서 여러 컴퓨터가 트랜잭션을 생성, 서명 및 브로드캐스트하는 방식은 어떻게 조율될 수 있을까?

단일 컴퓨터를 사용하여 트랜잭션에 서명하는 컴퓨터에 선착순으로 논스를 할당할 수 있다. 그러나 이 컴퓨터는 이제 단일 실패 지점이다. 더욱이, 여러 논스가 할당되고 그중 하나가 사용되지 않으면(해당 논스로 트랜잭션을 처리하는 컴퓨터 오류로 인해) 모든 후속 트랜잭션이 중단된다.

또 다른 방법은 트랜잭션을 생성하고 논스를 할당하지 않는 것이다(그러면 트랜잭션은 서명되지 않은 상태로 남는다. 논스는 트랜잭션 데이터의 필수 부분이므로 트랜잭션을 인증하는 디지털 서명에 포함시켜야 한다). 그런 다음, 이 서명되지 않은 트랜잭션들을 한 노드의 대기열에 올려서 이 노드가 트랜잭션을 서명하고 논스를 관리할 수 있게 하는 것이다. 물론, 이것이 프로세스상 병목 지점이 될 수는 있다. 서명하고 논스를 관리하는 작업은 시스템 부하가 늘어남에 따라 혼잡해질 수 있지만, 서명되지 않은 트랜잭션들을 생성하는 작업은 병렬 처리 문제를 고민하지 않아도 된다. 여전히 동시 실행 문제가 남아 있긴 하지만, 크리티컬한 프로세스 부분에서는 더 이상 존재하지 않게 된다.

결국, 이러한 동시 실행 문제는 각각의 독립적인 프로세스들이 어카운트 밸런스를 추적하고 트랜잭션을 컨펌해야 하는 어려움이 가중된다. 따라서 대부분의 구현 솔루션들이 동시 실행을 피하고 거래소에서 출금 트랜잭션을 처리하는 단일 프로세스를 만드는 것처럼 병목 지점을 어쩔 수 없이 받아들이거나, 독립적으로 작동하는 다수의 출금 담당 핫 월렛을 설치하고 중간중간에 각 지갑의 밸런스를 다시 채워주는 형식으로 해결하게끔 만든다.

## **3. 트랜잭션 가스**

가스는 이더리움의 연료다. 가스는 이더가 아니라 이더에 대한 자체 환율을 가진 별도의 가상화폐다. 이더리움은 가스를 사용하여 트랜잭션이 사용할 수 있는 자원의 양을 제어한다. 이는 전 세계 수천 대의 컴퓨터에서 처리되기 때문이다. 개방형(튜링 완전) 계산 모델은 DoS(Denial-of-Servie) 공격이나 실수로 막대한 자원을 소모하는 트랜잭션을 피하기 위해 특정한 형태의 미터링(metering)이 필요하다.

가스는 이더 가치의 급격한 변화와 함께 발생할 수 있는 변동성으로부터 시스템을 보호하고, 가스가 지급하는 다양한 자원(즉, 계산, 메모리 및 저장)의 비용 사이의 중요하고 민감한 비율을 관리하기 위해 가스를 이더와 분리한다.

트랜잭션의 gasPrice 필드는 트랜잭션 생성자가 가스와 교환하여 지급할 가격을 설정할 수 있게 한다. 가격은 가스 단위당 웨이 단위로 측정된다. 예를 들어, 2장의 샘플 트랜잭션에서 지갑은 gasPrice를 3Gwei(3기가웨이 또는 300억 웨이)로 설정한다.

> 인기 있는 사이트 [ETH 가스 충전소](https://ethgasstation.info/)는 이더리움 메인 네트워크의 가스 및 기타 관련된 가스 측정 항목의 현재 가격에 대한 정보를 제공한다.

지갑은 신속한 트랜잭션 컨펌을 위해 gasPrice를 조정할 수 있다. gasPrice가 높을수록 트랜잭션이 더 빨리 컨펌될 것이다. 반대로, 우선순위가 낮은 트랜잭션은 낮은 가격을 설정해서 컨펌이 느려지게 할 수 있다. gasPrice가 설정될 수 있는 최솟값은 0이고, 이것은 수수료 없는 트랜잭션을 의미한다. 블록 공간에 대한 수요가 낮은 기간에는 수수료가 0인 트랜잭션들도 블록에 포함될 수 있다.

> 최소 허용 gasPrice는 0이다. 이는 지갑이 완전히 무료 트랜잭션을 생성할 수 있음을 의미한다. 용량에 따라 이들은 영원히 컨펌되지 않을 수도 있지만, 프로토콜에 무료 트랜잭션을 금지하는 것은 없다. 이더리움 블록체인에 성공적으로 포함된 이와 같은 트랜잭션 사례들을 찾을 수 있다.

web3 인터페이스는 여러 블록에 걸친 중간 가격을 계산하여 gasPrice를 제안하는 기능을 제공한다(트러플 콘솔 또는 자바스크립트 web3 콘솔을 사용하여 이를 수행할 수 있다).

```
> web3.eth.getGasPrice(console.log)
> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
```

가스와 관련된 두 번째 중요한 필드는 gasLimit이다. 간단히 말하면, gasLimit은 트랜잭션을 완료하기 위해 트랜잭션을 시도하는 사람이 기꺼이 구매할 수 있는 최대 가스 단위 수를 제공한다. 단순 지급의 경우, 하나의 EOA에서 다른 EOA로 이더를 전송하는 트랜잭션을 의미하며, 필요한 가스양은 21,000개의 가스 단위로 고정된다. 얼마나 많은 양의 이더가 소비되는지 계산하려면, 지급하고자 하는 gasPrice에 21,000을 곱하라. 예를 들면 다음과 같다.

```
> web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )
> 210000000000000
```

트랜잭션 목적지 주소가 컨트랙트인 경우, 필요한 가스양을 추정할 수는 있지만 정확하게 결정할 수는 없다. 이는 컨트랙트가 각기 다른 경로로 이어지는 조건을 가질 수 있어 총 가스 비용이 다를 수 있기 때문이다. 컨트랙트는 통제할 수 없거나 예측할 수 없는 조건들에 의해 단순한 계산으로 끝날 수도 있고, 더 복잡한 계산을 수행해야 할 수도 있다. 예를 한번 들어보자. 호출될 때마다 카운터를 증가시키고 호출 횟수와 같은 횟수만큼 특정 루프를 실행하는 스마트 컨트랙트를 작성할 수 있다. 100번째 호출에서 복권과 같은 특별한 상을 줄 수도 있지만, 그것을 계산하려면 추가적인 연산이 필요하다. 컨트랙트를 99번 호출하는 동안 결과가 있었고, 100번째 호출에서 매우 다른 일이 발생한다. 지급할 가스의 양은 트랜잭션이 블록에 포함되기 전에 얼마나 많은 다른 트랜잭션이 해당 기능을 호출했는지에 따라 다르다. 여러분의 추정치는 99번째 트랜잭션을 기반으로 하지만, 트랜잭션이 확인되기 직전에 다른 사람이 99번째 컨트랙트를 요청한다. 이제 여러분은 호출할 수 있는 100번째 트랜잭션이고 계산 작업(및 가스 비용)은 훨씬 더 높다.

이더리움에서 사용되는 일반적인 비유를 빌리자면 gasLimit를 자동차의 연료 탱크 용량으로 생각할 수 있다(자동차가 트랜잭션이다). 여행에 필요한 만큼의 가스를 탱크에 채운다(트랜잭션 유효성 확인에 필요한 계산). 금액을 어느 정도 예측할 수 있지만, 연료 소비를 증가시키는 우회(좀 더 복잡한 실행 경로)같은 예기치 않은 변경사항이 있을 수 있다.

그러나 연료 탱크의 비유는 오해의 소지가 있고 여행이 완료된 후에 실제 가스 사용량에 따라 요금을 지급하는 주유 회사의 신용 계정과 좀 더 비슷하다. 트랜잭션을 전송할 때 첫 번째 유효성 확인 단계 중 하나는 그것이 발생된 계정이 (가스 가격 x 가스 요금)을 지급할 만큼 충분한 이더를 갖고 있는지 확인하는 것이다. 그러나 트랜잭션이 완료될 때까지 여러분의 계좌에서 금액이 실제로 차감되지 않는다. 트랜잭션에 의해 실제로 소비된 가스의 요금만 청구되지만, 트랜잭션을 보내기 전에 지급할 의사가 있는 최대 금액만큼 충분한 잔액이 있어야 한다.

## **4. 트랜잭션 수신자**

to 필드에 트랜잭션 수신자가 지정된다. 이것은 20바이트 이더리움 주소를 포함한다. 주소는 EOA 또는 컨트랙트 주소일 수 있다.

이더리움은 이 필드를 더는 검증하지 않는다. 모든 20바이트 값은 유효한 것으로 간주한다. 20바이트 값이 개인키가 없거나 상응하는 컨트랙트가 없는 주소의 경우에도 트랜잭션은 여전히 유효하다. 이더리움은 주소가 공개키(따라서 개인키)에서 올바르게 파생되었는지 여부를 알 수 있는 방법이 없다.

> 이더리움 프로토콜은 트랜잭션의 수신자 주소를 검증하지 않는다. 해당하는 개인키 또는 컨트랙트가 없는 주소로 보낼 수도 있다. 그러면 이더가 연소(burning)되어 영구적으로 사용할 수 없게 된다. 유효성 검사는 사용자 인터페이스 수준에서 수행되어야 한다.

트랜잭션을 잘못된 주소로 보내면, 대부분의 경우에 해당 주소에 대응하는 개인키도 알 수 없고 서명도 만들 수 없기 때문에, 보내진 이더는 다시 사용할 수 없는 상태가 되므로 영원히 소실된 것으로 간주할 수 있다. 주소 확인은 사용자 인터페이스 수준에서 처리해야 한다고 가정한다. 사실, 이더를 연소시키는 데는 여러 가지 정당한 이유가 있을 수 있다. 예를 들면, 지급 채널 및 기타 스마트 컨트랙트에서의 부정 행위를 저지하는 것이나, 이더의 양이 유한하므로 이더를 연소시키면 모든 이더 보유자에게 연소된 값을 효과적으로 분배한 것으로 이해할 수 있다(그들이 보유한 이더의 양에 비례하여).


