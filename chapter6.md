# **Chapter 6. 트랜잭션**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

트랜잭션은 외부 소유 계정(EOA)에 의해 서명된 메시지인데, 이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록된다. 이 기본 정의는 놀라울 정도로 매력적인 의미를 담고 있다. 다른 관점에서 바라보면, 트랜잭션은 EVM에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이라는 것이다. 이더리움은 글로벌 싱글톤 상태 머신이며, 트랜잭션은 이 상태 머신을 움직여서 상태를 변경할 수 있도록 만든다. 컨트랙트는 독자적으로 실행되지 않는다. 또한 이더리움도 자율적으로 실행되지 않는다. 모든 것은 트랜잭션으로부터 시작된다.

## **1. 트랜잭션 구조**

먼저 이더리움 네트워크에서 시리얼라이즈(serialize)되어 전송되는 트랜잭션의 기본 구조를 살펴보자. 시리얼라이즈된 트랜잭션을 수신하는 각 클라이언트와 애플리케이션은 자체 내부 데이터 구조를 사용하여 트랜잭션을 메모리에 저장하며, 네트워크에서 시리얼라이즈된 트랜잭션 자체에는 존재하지 않는 메타데이터가 포함되어 있다. 네트워크 시리얼라이제이션은 트랜잭션의 유일한 표준 형식이다.

트랜잭션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지다.

**논스(nonce)**
* 발신 EOA에 의해 발행되어 메시지 재사용을 방지하는 데 사용되는 일련번호

**가스 가격(gas price)**
* 발신자가 지급하는 가스의 가격(웨이)

**가스 한도(gas limit)**
* 이 트랜잭션을 위해 구입할 가스의 최대량

**수신자(recipient)**
* 목적지 이더리움 주소

**값(value)**
* 목적지에 보낼 이더의 양

**데이터(data)**
* 가변 길이 바이너리 데이터 페이로드

**v, r, s**
* EOA의 ECDSA 디지털 서명의 세 가지 구성요소

트랜잭션 메시지의 구조는 이더리움에서 간단하고 완벽한 바이트 시리얼라이제이션을 위해 특별히 만들어진 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 시리얼라이즈된다. 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디안 정수로 인코딩된다.

명확성을 위해 여기에 필드 라벨(수신자, 가스 한도 등)이 표시되지만, 이 필드 값들은 RLP로 인코딩된 필드 값이 들어 있는, 시리얼라이즈된 트랜잭션 데이터의 일부가 아니라는 점을 유의하자. 일반적으로 RLP는 필드 구분자 또는 라벨을 포함하지 않는다. RLP의 길이 접두어는 각 필드의 길이를 식별하는 데 사용된다. 따라서 정의된 길이를 초과하는 것은 구조상 다음 필드에 속한다.

이것이 실제 전송되는 트랜잭션 구조인데, 내부 정보를 보여주거나 사용자 인터페이스를 시각화하기 위해서는 트랜잭션 구조 이외에도 트랜잭션이나 블록체인에서 파생된 추가 정보를 사용한다.

예를 들어 발신자 EOA를 식별하는 주소에 '발신자(from)' 데이터가 없는데, 이것은 EOA의 공개키를 ECDSA 서명의 v, r, s 구성요소로부터 알아낼 수 있으며, 이는 공개키를 통해 주소를 알아낼 수 있음을 의미한다. 즉, 주소는 공개키에서 파생될 수 있다. '발신자' 필드가 표시된 트랜잭션이라면, 시각화하는 데 사용된 소프트웨어에 의해 추가된 것이다. 클라이언트 소프트웨어에 의해 트랜잭션에 자주 추가되는 다른 메타데이터는 블록 번호(채굴되고 블록체인에 포함된)와 트랜잭션 ID(계산된 해시)를 포함한다. 다시 말하면, 이 데이터는 트랜잭션에서 파생되며 트랜잭션 메시지 자체의 일부가 아니다.

## **2. 트랜잭션 논스**

논스(nonce)는 트랜잭션에서 가장 중요하고 이해하기 어려운 구성요소 중 하나다. 황서에서는 다음과 같이 정의한다.

논스 : 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계정의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값

엄밀히 말하면, 논스는 발신 주소의 속성이며 단지 발신 주소의 컨트랙트 안에서만 의미를 갖는다. 그러나 논스는 명시적으로 블록체인 계정 상태에 저장되지 않고, 해당 주소에서 발생한 확인된 트랜잭션 건수를 세어서 동적으로 계산되는 값이다.

아래의 두 가지 상황을 통해서 트랜잭션을 세는 논스의 중요성에 대해 알아보자. 하나는 트랜잭션 생성 순서대로 포함된다는 점에서 생기는 사용성상의 기능(usability feature)이며, 다른 하나는 트랜잭션 복제 방지라는 주요 기능에서의 측면이다. 이들 각각에 대한 예제 시나리오를 살펴보자.

1. 두 가지 트랜잭션을 한다고 생각해보자. 하나는 6개의 이더를 지급해야 하는 중요한 트랜잭션이고, 또 하나는 8개의 이더를 지급해야 하는 트랜잭션이다. 먼저 6이더 트랜잭션에 서명하고 전파하는 것이 더 중요하기 때문에 이 트랜잭션을 먼저 한 뒤, 두 번째 8이 더 트랜잭션에 서명하고 전파한다. 안타깝게도 계정에 이더가 10개밖에 없다는 사실을 간과했으므로, 네트워크에서 트랜잭션을 둘 다 받을 수 없어서 그중 하나는 실패한다. 더 중요한 6이더 트랜잭션을 먼저 보냈기 때문에 여러분은 당연히 앞선 트랜잭션은 성공하고 8이더 트랜잭션은 거부될 것으로 생각한다. 하지만 이더리움처럼 탈중앙화된 시스템에서 노드는 어떤 순서로든 트랜잭션을 수신할 수 있다. 특정 노드가 다른 노드보다 특정한 트랜잭션을 먼저 받을 것이라는 보장은 없다. 따라서 어떤 노드는 6이더 트랜잭션을 먼저 수신하고, 또 어떤 노드는 8이더 트랜잭션을 먼저 수신한다. 논스가 없다면 어느 것이 받아들여지고 어떤 것이 거부될지는 알 수 없다. 그러나 논스가 포함된 상태에서 보낸 첫 번째 트랜잭션은 논스 값이 예를 들어서 3이라고 하자. 8이더 트랜잭션은 다음 논스 값(즉, 4)을 갖는다. 그러면 0부터 3까지의 논스가 있는 트랜잭션이 처리될 때까지 해당 트랜잭션은 무시된다(8이더 트랜잭션이 먼저 수신되더라도).
2. 이제 당신의 계정에 100이더가 있다고 가정해보자. 당신이 정말로 사고싶어 하는 mcguffin-widget에 대한 지급을 이더로 받을 판매자를 찾는다. 그들에게 2이더를 보내면 그들은 mcguffin-widget을 보낸다. 2이더를 지급하기 위해, 당신의 계정에서 그들의 계정으로 2이더를 전송하는 트랜잭션에 서명한 다음, 트랜잭션을 이더리움 네트워크로 전파하여 검증한 후에 블록체인에 저장한다. 이제 논스 값 없이 2이더를 동일한 주소로 보내는 두 번째 트랜잭션은 첫 번째 트랜잭션과 정확히 동일하게 보인다. 즉, 이더리움 네트워크에서 트랜잭션을 보는 사람(수신자 또는 적을 포함하여 모든 사람을 의미함)은 원래 트랜잭션을 복사하여 붙여넣고 네트워크로 다시 보내는 방식으로 당신의 이더가 소진될 때까지 계속 트랜잭션을 반복해서 '재실행(reply)'할 수 있다. 그러나 트랜잭션 데이터에 포함된 논스 값을 사용하면 동일한 수신자 주소에 동일한 양의 이더를 여러 번 보내는 경우에도 각각의 개별 트랜잭션은 고유하다. 따라서 트랜잭션의 일부로 논스를 증가시킴으로써 누군가가 지급한 금액을 '복제(duplicate)'하는 행위를 막을 수 있다.

요약하면, 비트코인 프로토콜의 '미사용 트랜잭션 아웃풋(Unspent Transaction Output, UTXO)' 메커니즘과 달리, `계정 기반(account-based)` 프로토콜은 논스를 사용하는 것이 실제로 필수적임을 유의해야 한다.

### **2-1. 논스 추적**

