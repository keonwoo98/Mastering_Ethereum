# **Chapter 4. 암호학**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

이더리움의 기반 기술 중 하나는 컴퓨터 보안에 광범위하게 사용되는 수학의 한 분야인 `암호학(cryptography)`이다. 암호학은 그리스어로 `비밀 작성`을 의미하지만, 암호학 연구는 `암호화(encryption)`라고 하는 단순한 비밀 작성 이상의 것을 포함한다. 예를 들어 암호학은 그 비밀을 밝히지 않고 비밀의 지식을 증명하거나(예: 디지털 서명을 사용하여), 데이터의 진위성을 증명하는 데(예: 해시라고도 알려진 디지털 지문을 활용하여) 사용할 수 있다. 이런 유형의 암호화 증명은 이더리움 플랫폼(실제로 모든 블록체인 시스템)의 작동을 위한 중요한 수학 도구이며, 이더리움 애플리케이션에도 광범위하게 사용한다.

출판 시점 기준으로 이더리움 프로토콜의 어떤 부분도 암호화되어 있지 않다. 즉, 이더리움 플랫폼과 노드 간(트랜잭션 데이터 포함)의 모든 통신은 암호화되어 있지 않고, (따라서) 누구나 그 내용을 읽을 수 있다. 이렇게 해서 모든 사람이 상태 업데이트의 정확성을 확인할 수 있고, 합의에 도달할 수 있다. 향후에는 영 지식 증명(zero knowledge proof)과 동형 암호화(homomorphic encryption) 같은 고급 암호화 도구를 사용하여 여전히 합의를 가능하게 하면서도 암호화된 계산을 블록체인에 기록할 수 있을 것이다. 하지만 고급 암호화 도구를 제공할 준비는 마쳤으나 아직 배포되지는 않았다.

이 장에서는 이더리움에서 사용하는 암호 방식, 즉 개인키와 주소의 형태로 자금의 소유권을 제어하는 데 사용되는 공개키 암호화(Public Key Cryptography, PKC)를 소개한다.

## **1. 키와 주소**

이더리움은 `외부 소유 계정(Externally Owned Account, EOA)`과 `컨트랙트(contract)`라는 두 가지 유형을 계정을 갖고 있다. 디지털 `개인키(private key)`, `이더리움 주소(Ethereum address)`, `디지털 서명(digital signature)`을 통해 외부 소유 계정의 이더 소유권을 확립한다. 개인키는 모든 사용자와 이더리움 간 상호작용의 핵심이다. 사실, 계정 주소는 개인키에서 직접 파생되고, 개인키는 `계정(account)`이라고도 불리는 단일 이더리움 주소를 고유하게 결정한다.

이더리움 시스템은 개인키를 이더리움에 전송하거나 저장하는 방식으로 직접 사용하지 않는다. 즉, 개인키는 비공개로 유지되어야 하고, 네트워크로 전달된 메시지에 나타나지 않으며, 체인에 저장되어서도 안 된다. 계정 주소와 디지털 서명만 이더리움 시스템에 전송되고 저장된다. 개인키는 안전하고 확실하게 보관해야 한다.

개인키를 사용하여 생성된 디지털 서명을 통해 자금의 접근과 통제가 이루어진다. 이더리움 트랜잭션은 유효한 디지털 서명이 블록체인에 있어야 한다. 개인키의 사본을 가진 사람은 누구나 해당 계정과 해당 계정이 가진 이더를 제어할 수 있다. 사용자가 자신의 개인키를 안전하게 유지한다면, 이더리움 트랜잭션의 디지털 서명은 개인키의 소유권을 증명하기 때문에 자금의 실제 소유자임도 증명한다.

이더리움에서 사용하는 것과 같은 공개키 암호화 기반 시스템에서 키는 개인(비밀)키와 공개키로 구성된 쌍으로 제공한다. 공개키는 은행 계좌 번호와, 개인키는 PIN(개인 식별 번호)과 유사하다고 생각해 보자. 후자는 계정에 대한 제어권을 제공하고, 전자를 가지고 계정을 식별할 수 있다. 개인키 자체는 이더리움 사용자에게 드러나는 경우가 거의 없다. 대부분 암호화된 형태로 특수 파일에 저장하고, 이더리움 지갑 소프트웨어로 관리한다.

이더리움 트랜잭션의 지급 부분에서 지정된 수신자는 이더리움 주소로 표시하며, 이 주소는 은행 송금의 수익자 계좌 세부 정보와 동일한 방식으로 사용한다. 이후에 자세히 볼 수 있듯이 외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다. 그러나 모든 이더리움 주소가 공개키-개인키 쌍을 나타내는 것은 아니다. 개인키로 뒷받침되지 않는 컨트랙트를 표시할 수도 있다.

## **2. 공개키 암호화와 암호화폐**

공개키 암호화(비대칭 암호화라고도 함)는 오늘날 정보 보안의 핵심 요소다. 1970년대 마틴 헬먼(Martin Hellman), 휫필드 디피(Whitfield Diffie), 랄프 머클(Ralph Merkle)이 처음 공개한 이 기법은 암호학 분야에서 대중의 관심을 불러일으킨 기념비적인 돌파구였다. 70년대 이전에, 정부는 강력한 암호학 지식을 비밀로 유지했다.

공개키 암호화는 고유한 키를 사용하여 정보를 보호한다. 이 키는 특수한 속성(계산하기는 쉽지만 그 역(inverse)을 계산하기는 어렵다)을 가진 수학 함수를 바탕으로 한다. 이런 함수를 바탕으로한 암호화는 디지털 비밀과 위조 불가능한 디지털 서명을 만들 수 있으며, 이것은 수학 법칙에 의해 보장받는다.

예를 들어, 2개의 큰 소수를 곱하는 것은 아주 간단하다. 그러나 2개의 큰 소수의 곱을 감안할 때 소인수(`소인수 분해(prime factorization)`라고 하는 문제)를 찾는 문제는 매우 어렵다. 8,018,009라는 숫자가 두 소수의 결과라고 제시했을 때 그 두 소수를 찾는 것이 8,018,009를 만들기 위해 그 소수를 곱하는 것보다 훨씬 더 어렵다.

이런 수학 함수 중 일부는 비밀 정보를 알고 있을 때 쉽게 거꾸로 계산할 수 있다. 앞의 예에서 소인수 중 하나가 2,003이라고 하면, 간단히 나머지 소인수를 쉽게 찾을 수 있다(8,018,009 ÷ 2,003 = 4,003). 이런 함수는 역산하기 위한 단축키로 사용할 수 있는 비밀 정보가 없으면 거꾸로 계산하기 어렵기 때문에 `트랩 도어 함수(trapdoor function)`라고도 한다.

암호화에 유용한 수학 함수의 좀 더 발전된 범주는 타원 곡선의 산술 연산을 바탕으로 한다. 타원 곡선 산술에서 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈(역함수)은 사실상 불가능하다. 이것을 `이산 로그 문제(discrete logarithm problem)`라고 하며, 현재는 알려진 트랩 도어는 없다. `타원 곡선 암호화(elliptic curve cyptography)`는 최신 컴퓨터 시스템에서 광범위하게 활용되며, 이더리움(및 기타 암호화폐)에서 개인키와 디지털 서명을 사용하는 기초가 된다.

> ※ 페르마의 마지막 정리를 증명하는 과정에서 쓰였던 타원곡선이론은 현재 실생활에서 암호체계로써 많이 쓰이고 있다. 마국의 국가 안보국 NSA도 타원곡선암호 방식을 채택하고 있다. 타원곡선암호의 대표적인 장점은 공개키 암호방식에서 공개키 보다 짧은 키로써 비슷한 수준의 안전성을 제공한다는 것이다. 때문에 전송량이라던가 계산량이 제한된 무선환경들에서 그 장점이 부각된다. 교통카드, 신용카드, 의료보험증 등이 타원곡선암호체계를 이용하고 있고, 비트코인 또한 타원곡선암호 방식으로부터 만들어진 시스템이다.

> * [암호학 WIKI](https://en.wikipedia.org/wiki/Cryptography)
> * [트랩 도어 함수 WIKI](https://en.wikipedia.org/wiki/Trapdoor_function)
> * [소인수 분해](https://en.wikipedia.org/wiki/Integer_factorization)
> * [이산 로그](https://en.wikipedia.org/wiki/Discrete_logarithm)
> * [타원 곡선 암호화](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)

이더리움에서는 공개키 암호화(비대칭 암호화라고도 함)를 사용하여 이 장에서 설명한 공개키-개인키 쌍을 만든다. 공개키는 개인키에서 파생되므로 '쌍'으로 간주한다. 그와 함께, 그 쌍은 공개적으로 접근할 수 있는 계정 핸들(주소)과 계정의 이더에 대한 접근 권한, 그리고 스마트 컨트랙트를 사용할 때 계정이 필요로 하는 모든 인증에 대한 사적 제어권을 제공함으로써 이더리움 계정을 나타낸다. 개인키는 계정에서 자금을 지출하기 위해 트랜잭션에 서명해야 하는 `디지털 서명(digital signature)`을 만드는 데 필요한 고유한 정보의 접근을 제어한다. 디지털 서명은 소유자 또는 컨트랙트 사용자를 인증하는 데도 사용한다.

> 대부분의 지갑 구현에서 개인키와 공개키는 편의상 키 쌍(key pair)으로 함께 저장한다. 그러나 공개키는 개인키로부터 간단히 계산될 수 있으므로 개인키만 저장하는 것도 가능하다.

디지털 서명을 만들어 모든 메시지에 서명할 수 있다. 이더리움 트랜잭션에서는 트랜잭션 자체의 세부사항이 메시지로 사용된다. 암호 수학(이번 예는 타원 곡선 암호화)은 메시지(즉, 트랜잭션 세부 정보)를 개인키와 결합하여 개인키를 알아야만 만들 수 있는 코드 생성 방법을 제공한다. 이 코드를 디지털 서명이라고 한다. 이더리움 트랜잭션은 기본적으로 특정 이더리움 주소로 특정 계정에 접근하는 요청이다. 자금을 이동하거나 스마트 컨트랙트와 상호작용하기 위해 트랜잭션을 이더리움 네트워크로 보내면, 문제의 이더리움 주소에 해당하는 개인키로 생성된 디지털 서명도 함께 보내야 한다. 타원 곡선 수학이란 디지털 서명, 트랜잭션 세부 정보, 접근하려는 이더리움 주소가 일치하는지 확인하여 '누구나' 트랜잭션이 유효한지 확인할 수 있음을 의미한다. 이러한 확인 과정에는 개인키가 전혀 포함되지 않는다. 개인키는 개인 영역에 남아 있다. 그러나 검증 프로세스에서는 의심의 여지 없이 그 트랜잭션이 공개키에 대응되는 개인키를 가진 사람에 의해 만들어졌음을 확증할 수 있다. 이것이 공개키 암호화의 '마법'이다.

> 이더리움 프로토콜에는 암호화가 없기 때문에, 이더리움 네트워크 동작의 일부로 보내는 모든 메시지는 모든 사람이 (불가피하게) 읽을 수 있다. 따라서 개인키는 트랜잭션 인증을 위한 디지털 서명을 만드는 데에만 사용한다.

## **3. 개인키**

개인키는 단순히 무작위로 선택한 숫자다. 개인키의 소유권과 제어는 해당 주소를 승인하는 컨트랙트에 대한 접근뿐만 아니라 해당 이더리움 주소와 관련된 모든 자금에 대한 사용자 제어의 근원이다. 개인키는 트랜잭션에 쓰이는 자금의 소유권을 증명함으로써 이더를 소비하는데 필요한 서명을 만드는 데 사용된다. 개인키는 항상 비밀로 유지해야 한다. 왜냐하면 개인키를 제3자에게 공개하는 행위는 개인키로 확보한 컨트랙트와 이더에 대한 제어 권한을 제3자에게 부여하는 것이나 마찬가지이기 때문이다. 개인키는 반드시 백업하여 우발적인 손실로부터 보호해야 한다. 한번 잃어버리면 되찾을 수 없으며, 해당 키로 확보한 자금도 영원히 잃어버리게 된다.

> 이더리움 개인키는 숫자다. 비공개키를 무작위로 선택하는 방법 중 하나는 동전, 연필, 종이를 사용하는 것이다. 동전을 256번 던져서 이더리움 지갑에서 사용할 수 있는 2진수로 된 임의의 개인키를 얻을 수 있다. 공개키와 주소는 이 개인키로부터 생성될 수 있다.

### **3-1. 난수로 개인키 생성**

키를 생성하는 가장 중요한 첫 번째 단계는 엔트로피, 즉 무작위성을 확보하는 것이다. 이더리움 개인키를 생성하는 것은 기본적으로 1에서 2^256 사이의 숫자를 선택하는 것이라고 볼 수 있다. 해당 번호를 선택하는 것이 예측 가능하거나 결정적이라면 이 번호 선택 방법은 중요해진다. 이더리움 소프트웨어는 기본 운영체제의 난수 생성기를 사용하여 256개의 임의 비트를 생성한다. 일반적으로 OS 난수 생성기는 사람이 무작위의 소스가 되어 초기화되므로 몇 초 동안 마우스를 움직이거나 키보드에서 임의의 키를 누르라는 요청을 받을 수 있다. 컴퓨터의 마이크로폰 채널에서 나오는 우주 방사선 노이즈가 대안이 될 수 있다.

좀 더 정확히 말하자면, 개인키는 2^256보다 약간 작은 0이 아닌 매우 큰 숫자(거대한 78자리 숫자, 대략 1.158 x 10^77)까지 가능하다. 정확한 숫자는 첫 번째 38자리를 2^256으로 공유하며, 이더리움에서 사용된 타원 곡선 순서로 정의한다. 비공개 키를 생성하기 위해 256비트 숫자를 무작위로 추출하여 유효한 범위 내에 있는지 확인한다. 프로그래밍 측면에서 이것은 일반적으로 더 큰 임의의 비트 문자열(암호학적으로 안전한 임의성 소스에서 수집됨)을 Keccak-256 또는 SHA-256 같은 256비트 해시 알고리즘에 공급함으로써 이루어 진다. 두 가지 알고리즘 모두 편리하게 256비트 수를 생성한다. 결과가 유효한 범위 내에 있으면 적절한 개인키가 된다. 그렇지 않으면 다른 임의의 숫자로 다시 시도하기만 하면 된다.

 > 2^256(이더리움 개인키 공간 크기)은 대단히 큰 숫자다. 10진수로 약 10^77, 즉 77자리 숫자다. 비교를 해보자면, 우리가 보는 우주는 10^80개의 원자를 포함하는 것으로 추정된다. 따라서 우주에 있는 모든 원자에 이더리움 계정을 제공하기에 충분할 만큼의 개인키가 있다. 하나의 개인키를 무작위로 선택했을 때, 누군가가 그것을 추측하거나 스스로 같은 값을 선택할 수 있는 가능한 방법은 현재 없다.

 개인키 생성 프로세스는 오프라인 프로세스다. 그것은 이더리움 네트워크와의 통신이나 다른 사람과의 통신을 필요로 하지 않는다. 따라서 아무도 선택할 수 없는 숫자를 선택하려면 그것은 정말로 무작위적이어야 한다. 만약 여러분이 직접 그 번호를 선택한다면, 다른 사람이 그것을 시도해서 같은 번호를 찾을 수 있는 확률이 너무 높다. 나쁜 난수 생성기(대부분의 프로그래밍 언어에 있는 의사 난수 rand 함수와 같은)를 사용하는 것은 복제하기가 훨씬 더 쉽기 때문에 더 나쁘다. 온라인 계정의 암호와 마찬가지로 개인키도 추측할 수 없어야 한다. 다행히도 개인키를 기억할 필요가 없으므로 가능한 한 최선의 접근 방식을 취할 수 있다. 즉, 진정한 무작위성이다.

 > 임의의 숫자를 만들거나 프로그래밍 언어에서 제공하는 '간단한' 난수 생성기를 사용하는 코드는 작성하지 마라. 충분한 엔트로피 원천의 시드(seed)와 함께 암호로 안전한 의사 난수 생성기(예: CSPRNG)를 사용하는 것이 중요하다. 암호로 보호되어 있는지 확인하기 위해 사용하고자 하는 난수 생성기 라이브러리의 문서를 학습하라. CSPRNG 라이브러리의 올바른 구현은 키 보안에 중요하다.

 다음은 임의로 생성한 16진수 형식의 개인키다(256비트는 64비트 16진수로 표시, 각 4비트).

 ```
 f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
 ```

## **4. 공개키**

이더리움 공개키는 타원 곡선에 있는 `점(point)`으로 타원 곡선 방정식을 만족하는 x와 y 좌표의 집합을 의미한다.

더 간단한 용어로, 이더리움 공개키는 함께 결합된 2개의 숫자다. 이 숫자는 개인키로부터 `단방향으로만` 계산할 수 있다. 즉, 개인키가 있는 경우 공개키를 계산하기는 쉽지만, 공개키에서 개인키를 계산할 수는 없다.

공개키는 사실상 비가역적인 타원 곡선 곱셈을 사용하여 개인키로부터 계산된다. `K = k * G`, 여기서 k는 개인키, `G`는 `생성자 점(generator point)`이라고 불리는 상수점, `K`는 결과로 나오는 공개키, `*`는 특수 타원 곡선 곱하기 연산자다. 타원 곡선을 일반적인 곰셈과 같지 않다. 일반적인 곱셈과 기능적 속성을 공유하지만 그것뿐이다. 예를 들어, '이산 로그 찾기'(K를 알고 있는 경우 k를 계산한다)로 알려진 역 연산(정상 수에 대한 나눗셈)은 가능한 모든 `k`값을 시도하는 것만큼 어렵다(우주가 허용하는 것보다 더 많은 시간이 걸리는 무차별 대입 탐색).

간단히 말하면, 타원 곡선에 대한 산술 연산은 '정규'정수 연산과 다르다. 점(G)에 정수(k)를 곱하여 다른 점(K)을 생성할 수 있다. 그러나 나눗셈(division)같은 연산이 존재하지 않으므로 공개키 K를 G점으로 간단히 '나누어서' 개인키 k를 계산할 수 없다. 이것이 단방향 수학 함수다.

> 타원 곡선 곱셈은 암호학자가 '단방향'함수라고 부르는 함수 유형이다. 한 방향(곱하기)으로는 수행하기 쉽고 반대 방향(나누기)으로는 수행하기가 쉽지 않다. 개인키의 소유자는 아무도 함수를 되돌려서 공개키에서 개인키를 계산할 수 없다는 것을 알고 공개키를 쉽게 생성하여 세상과 공유할 수 있다. 이 수학적 트릭은 이더리움 자금의 소유권과 계약 관리를 입증하는 위조 불가능하고 안전한 디지털 서명의 기초가 된다.

### **4-1. 타원 곡선 암호화 설명**

타원 곡선 암호화는 타원 곡선의 점에 더하기와 곱셈으로 표현되는 이산 대수 문제를 바탕으로 한 비대칭 또는 공개키 암호화 유형이다.

[그림 4-1]은 이더리움에서 사용하는 것과 비슷한 타원 곡선의 한 예다.

> 이더리움은 비트코인처럼 secp256k1이라는 정확한 타원 곡선을 사용한다. 따라서 비트코인의 타원 곡선 라이브러리 및 도구를 재사용할 수 있다.

**[그림 4-1] 타원 곡선의 시각화**

![](https://images.velog.io/images/dogfootbirdfoot/post/1d7719df-eec7-4620-8b12-b8a8d7dcbb3f/%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B71.png)

이더리움은 `미국 표준기술연구소(National Institute of Standards and Technology, NIST)`에서 제정한 `secp256k1`이라는 표준에 정의한 대로 특정 타원 곡선과 수학 상수 집합을 사용한다.

`secp256k1` 곡선은 타원 곡선을 생성하는 다음 함수로 정의한다.

`y^2 = (x^3 + 7)over(𝔽 p)`

또는

`y^2 mod p = (x^3 + 7) mod p`

`mod p`(소수 p로 나눈 나머지)는 이 곡선이 `𝔽 p`라고 쓰인 소수 차수 `p`의 유한체상에 있음을 나타낸다. 여기서 `p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1`로, 매우 큰 소수다.

이 곡선은 실수 대신에 소수 위수의 유한체상에 정의했기 때문에 2차원으로 흩어져 있는 점들의 패턴처럼 보인다. 그래서 시각화하기 어렵다. 그러나 수학은 실수에 대한 타원 곡선 수학과 동일하다. 예를 들어, [그림 4-2]에서 보여주는 좌표 위의 점 패턴은 훨씬 작은 유한체인 소수 위수 17의 타원 곡선과 동일하다. `secp256k1` 이더리움 타원 곡선은 헤아릴 수 없을 만큼 큰 좌표에서 훨씬 더 복잡한 점 패턴으로 생각할 수 있다.

**[그림 4-2] 타원 곡선 암호화 : p = 17일 때 F(p)에서 타원 곡선을 시각화**

![](https://images.velog.io/images/dogfootbirdfoot/post/92bfb01a-60fa-4eef-b4f9-e6d1fcc58d2b/%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B72.png)

예를 들어, 다음은 `secp256k1` 곡선상의 점인 (x, y)를 갖는 점 Q이다.

```
Q =
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
```

[예제 4-1]은 파이썬을 사용하여 직접 확인하는 방법이다. 변수 x와 y는 앞의 예와 같이 점 Q의 좌표다. 변수 p는 타원 곡선의 소수(모든 모듈로 연산에 사용되는 소수)다. 파이썬의 마지막 줄은 타원 곡선 방정식이다(파이썬의 % 연산자는 모듈러 연산자다). x와 y가 실제로 타원 곡선상의 한 점의 좌표라면, 그들은 방정식을 만족하고 결과는 0이다(0L은 값이 0이 긴 정수임). 커맨드라인에 `python`을 입력하고 목록에서 각 줄을 (>>> 프롬프트 다음에) 복사하여 직접 해보자.

**[예제 4-1] 파이썬을 사용하여 이 점이 타원 곡선에 있음을 확인함**

```bash
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834 \
671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0L
```

### **4-2. 타원 곡선 산술 연산**

많은 타원 곡선 수학은 우리가 학교에서 배운 정수 산술과 매우 흡사하다. 특히 우리는 더하기 연산자를 정의할 수 있다. 이 연산자는 숫자 선을 따라 점프하는 대신 곡선의 다른 점으로 점프한다. 일단 우리가 덧셈 연산자를 가지면, 점의 정수의 곱셈을 정의할 수 있다. 이것은 반복되는 덧셈과 같다.

타원 곡선에 두 점 P1과 P2가 주어지면 세 번째 점 P3 = P1 + P2가 타원 곡선 위에 있도록 곡선 덧셈을 정의한다.

기하학적으로 이 세 번째 점 P3은 P1과 P2 사이의 선을 그려 계산한다. 이 선은 정확하게 하나의 추가 장소(놀랍게도)에서 타원 곡선과 교차한다. 이 점을 P3' = (x, y)라고 부르자. 이어서 x축에 반사하여 P3 = (x, -y)를 구한다.


