# **Chapter 5. 지갑**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

이더리움에서는 '지갑'이라는 단어를 몇 가지 다른 것을 설명하는 데 사용한다.

넓은 의미에서 지갑은 이더리움의 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션이다. 지갑은 사용자 돈에 대한 접근을 통제하고, 키와 주소를 관리하며, 잔액을 추적하고, 트랜잭션 생성과 서명을 제어한다. 여기에 더해서 몇몇 이더리움 지갑은 ERC20 토큰처럼 컨트랙트와 상호작용할 수 있다.

개발자의 시각으로 좀 더 좁혀보면, `지갑(wallet)`이란 단어는 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템을 의미하며, 모든 지갑은 키 관리 구성요소를 갖고 있다. 그 자체로 전부인 지갑도 있고, 좀 더 넓은 범주에서 이더리움 기반 탈중앙화 애플리케이션의 인터페이스인 브라우저(browser)의 일부이거나, DApp의 한 부분인 지갑도 있다. 지갑이라는 단어에 함축된 다양한 범주를 구분할 수 있는 명확한 기준은 없다.

이번 장에서는 개인키를 담는 공간이자 키를 관리하는 시스템으로서 지갑을 살펴볼 것이다.

## **1. 지갑 기술의 개요**

지갑을 설계할 때 중요한 고려사항 하나는 편의성과 프라이버시 사이에 균형을 맞추는 것이다. 가장 편리한 이더리움 지갑은 하나의 개인키 주소를 가지고 이를 재사용해서 모든 것을 처리하는 지갑이다. 하지만 불행하게도 그러한 솔루션(solution)은 누구나 쉽게 여러분의 모든 트랜잭션을 추적하고 연결하여 볼 수 있으므로 프라이버시에 대한 악몽이 될 수 있다. 모든 트랜잭션에 새로운 키를 사용하는 것이 프라이버시를 위해 가장 좋지만 관리하기가 몹시 어렵다. 그 사이에서 적절한 균형을 달성하기가 쉽지 않는데, 이것이 바로 좋은 지갑을 설계하는 것이 다른 무엇보다 중요한 이유다.

이더리움에 관한 일반적인 오해 중 하나는 이더리움 지갑이 이더 혹은 토큰을 보유한다는 것이다. 사실 매우 엄격하게 말하자면 지갑은 단지 키만 보유한다. 이더 혹은 다른 토큰은 이더리움 블록체인에 기록된다. 사용자는 지갑에 있는 키로 트랜잭션을 서명함으로써 네트워크에서 토큰을 제어한다. 이러한 맥락에서 이더리움 지갑은 `키체인(keychain)`이다. 지갑에 있는 키가 이더나 토큰을 전송하는 데 필요한 유일한 것이라고 생각하면, 실제로 이렇게 구분하는 것이 큰 의미는 없다. 중요한 것은 기존 은행(여러분과 은행만이 여러분의 계좌에 있는 돈을 볼 수 있고 트랜잭션을 위해 자금을 옮기고 싶다고 은행만 납득시키면 된다)의 중앙화된 시스템을 다루는 것에서부터 블록체인 플랫폼(모든 사람이 계좌의 이더 잔액을 볼 수 있고 계좌 주인을 알지 못하지만 소유자는 트랜잭션 진행을 위해 자금을 옮기고 싶어 한다는 것을 모든 사람에게 납득시켜야 한다)의 탈중앙화된 시스템으로 사고방식을 바꾸는 것이다. 실제로 이것은 지갑이 없이도 계좌의 잔액을 확인하는 독립적인 방법이 있음을 의미한다. 더구나, 사용하던 지갑 앱(app)이 싫어지면 현재 지갑에서 다른 지갑으로 계정을 옮길 수 있다.

> 이더리움 지갑은 키는 포함하고 이더나 토큰은 포함하지 않는다. 지갑은 개인키와 공개키 쌍을 포함하는 키체인과 같은 것이다. 사용자는 개인키로 트랜잭션에 서명함으로써 이더가 자신의 소유임을 증명한다. 이더는 블록체인에 저장된다.

지갑은 주요한 두 가지 형태가 있는데, 지갑이 포함하는 키가 서로 관련이 있느냐 없느냐에 따라 구분된다.

첫 번째 유형은 각기 다른 무작위 수로부터 각각의 키를 무작위적으로 추출하는 `비결정적 지갑(nondeterministic wallet)`이다. 이러한 형태의 지갑을 '그냥 열쇠뭉치(Just a Bunch Of Keys)'라는 뜻의 JBOK 지갑이라 부른다.

두 번째 유형은 모든 키가 `시드(seed)`라고 하는 단일 마스터 키로부터 파생된 `결정적 지갑(deterministic wallet)`이다. 이러한 지갑 형태의 모든 키는 서로 관련이 있고 원래의 시드를 갖고 있다면 다시 키를 파생시킬 수 있다. 결정적 지갑에는 여러 가지 `키 파생(key derivation)` 방식이 있는데, 가장 많이 사용하는 파생 방식은 이 후에 나오는 'HD 지갑(BIP-32/BIT-44)'절에서 설명하는 트리 같은 구조를 사용한다.

휴대전화를 도난당하거나 화장실에 떨어뜨림으로써 데이터를 분실할 수 있다. 따라서 좀 더 안전한 결정적 지갑을 만들기 위해서 시드는 단어 목록(영어 또는 기타 언어)으로 인코딩되어 불의의 사고에 대비할 수 있도록 적어두고 사용한다. 이를 지갑의 `니모닉 코드 단어(mnemonic code words)`라고 한다. 물론, 누군가가 여러분의 니모닉 코드 단어를 손에 넣으면 지갑을 재생성하여 여러분의 이더와 스마트 컨트랙트에 접근할 수 있다. 그러므로 복구 단어 목록은 아주 조심스럽게 다루고 절대로 컴퓨터나 휴대전화의 전자파일로 저장하지 말고 종이에 적어서 안전한 곳에 보관해야 한다.

### **1-1. 비결정적(무작위) 지갑**

첫 번째 이더리움 지갑(이더리움 사전 판매용으로 생성된)은 각 지갑 파일에 무작위로 추출된 단일 개인키를 저장했다. 이런 '이전 스타일' 지갑은 여러 측면에서 불편하기 때문에 결정적 지갑으로 대체되고 있다. 예를 들어, 이더리움을 사용하는 동안 프라이버시를 극대화한다는 차원에서는 이더리움 주소의 재사용을 피하는 것이 좋은 지침으로 간주된다. 즉, 자금을 받을 때마다 새로운 주소(새로운 개인키가 필요한)를 사용한다. 이렇게 하려면 비결정적 지갑은 정기적으로 키 목록을 증가시켜야 하는데, 이는 정기적인 백업이 필요하다는 뜻이다. 만약 지갑을 백업하기 전에 데이터(디스크 고장, 음료 사고, 휴대전화 도난)를 잃어버리면 자금과 스마트 컨트랙트에 접근할 수 없게 된다. '타입 0'으로 볼 수 있는 비결정적 지갑을 '때마다(just in time)' 모두 새로운 주소를 위한 지갑 파일을 만들기 때문에 다루기가 가장 어렵다.

그러므로 불구하고 많은 이더리움 클라이언트(게스 포함)는 보안 강화를 위해 암호문으로 암호화된 단일(무작위로 생성된) 개인키가 들어 있는, JSON 인코딩 파일인 `키저장소(keystore)` 파일을 사용한다. JSON 파일의 내용은 다음과 같다.

```
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```

키저장소 형식은 무차별(brute-force), 사전(dicionary) 및 레인보우 테이블(rainbow table) 공격을 대비해 암호 확장 알고리즘으로 알려진 `키 파생 함수(key derivation function, KDF)`를 사용한다. 간단히 말해서, 개인키는 암호문에 의해 직접적으로 암호화되지 않는다. 대신, 암호문은 반복적으로 해싱됨으로써 강화된다. 해시 함수는 262,144 라운드로 반복되며, 키저장소 JSON에서 파리미터 crypto.kdfparams.n으로 확인할 수 있다. 공격자가 암호문을 무차별적으로 생성하려면 암호화를 시도할 때마다 262,144 해시 라운드를 적용해야 할 것이다. 이것은 공격 속도를 늦추어 복잡하고 길이가 긴 암호문에 대한 공격을 불가능하게 한다.

자바스크립트 라이브러리 [keythereum](https://github.com/ethereumjs/keythereum)과 같이 키저장소 형식을 읽고 쓸 수 있는 여러 소프트웨어 라이브러리가 있다.

> 비결정적 지갑은 간단하 테스트 외에는 사용을 권장하지 않는다. 왜냐하면 가장 단순한 상황 이외에는 백업하고 사용하기가 매우 불편하기 때문이다. 대신, 백업을 위해 니모딕 시드가 있든 산업계 표준인 HD(hierarchical deterministic) 지갑을 사용하라.

### **1-2. 결정적(시드) 지갑**

결정적 혹은 '시드' 지갑은 단일 마스터 키 또는 '단일 시드'로부터 파생된 개인키를 포함하고 있다. 시드는 개인키를 만들기 위해 인덱스 번호나 '체인 코드(chain code)'같은 데이터와 결합된 무작위로 추출된 번호다. 결정적 지갑에서 시드는 모든 파생된 키를 복구할 수 있다. 그러므로 생성 시점에 단일 백업으로 지갑에 있는 모든 자금과 컨트랙트를 안전하게 보호할 수 있다. 시드는 또한 지갑을 내보내거나(export) 가져오기(import)에 활용되고 다른 지갑 간에 모든 키를 쉽게 이관할 수 있다.

이러한 구조로 인해 시드만 있으면 전체 지갑에 접근이 가능하기 때문에 시드의 보안이 최우선적인 과제가 된다. 한편, 보안 노력을 단일 데이터에 집중할 수 있다는 것은 장점으로 볼 수 있다.

### **1-3. HD지갑(BIP-32/BIP-44)**

결정적 지갑은 단일 시드로부터 아주 많은 키를 쉽게 추출하기 위해 개발되었다. 현재 가장 개선된 결정적 지갑은 비트코인의 [BIP-32 표준](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)으로 정의된 `HD(hierarchical deterministic)`지갑이다. HD 지갑은 트리 구조로 파생된 키들을 가지고 있다. 이러한 구조는 부모 키가 자식 키의 시퀀스(sequence)를 파생할 수 있고, 각각의 자식은 다시 또 손자 키의 시퀀스를 파생할 수 있다. 이 트리의 구조는 [그림 5-1]에 나와 있다.

**[그림 5-1] HD 지갑 : 단일 시드로부터 생성된 키 트리**



HD 지갑은 결정적 지갑에 비해 몇 가지 장점을 지닌다. 먼저, 트리 구조는 예를 들어 하위 키의 특정 분기(branch)는 입금을 받는 데 사용하고 다른 분기는 송금 후 잔액을 받는 데 사용할 수 있으며, 또한 부서, 자회사, 특정 기능 혹은 회계 범주로 다른 분기를 할당하여 기업 환경 설정과 같은 구조적인 의미를 표현하는 데도 사용할 수 있다.

HD 지갑의 두 번째 장점은 개인키에 접속하지 않고 사용자가 공개키 시퀀스를 만들 수 있다는 것이다. HD 지갑은 보안상 안전하지 않는 서버, 보기 전용, 수신 전용의 용도로 사용할 수 있는데, 이때 지갑에는 자금을 움직이는 개인키가 들어 있지 않게 만들 수 있다.

### **1-4. 시드와 니모닉 코드(BIP-39)**

안전한 백업 및 검색을 위해 개인키를 인코딩하는 데는 다양한 방법이 있다. 현재 많이 사용하는 방법은 단어 시퀀스를 사용하는 것인데, 이는 올바른 순서로 단어 시퀀스가 입력되면 고유한 개인키를 다시 만들 수 있다. 이러한 방법을 `니모닉(mnomonic)`이라 하고, 이러한 접근은 [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)에 의해 표준화되었다. 요즘 많은 이더리움 지갑(기타 암호화폐 지갑을 포함하여)은 이 표준을 사용하여 백업 및 복구를 위해 호환이 가능한 니모닉으로 시드 가져오기(import)나 내보내기(export)를 할 수 있다.

왜 이러한 접근을 선호하는지 다음 예제를 확인해 보자.

```
FCCF1AB3329FD5DA3DA9577511F8F137

wolf juice proud gown wool unfair
wall cliff insect more detail hub
```

실용적인 측면에서, 16진수 시퀀스를 기록할 때는 오류가 발생할 확률이 매우 높다. 반대로 알려진 단어 목록은 단어(특히 영어 단어)들을 사용할 때 중복성이 커서 다루기가 매우 쉽다. 만약 'inzect'라고 우연히 기록된 게 있다면, 지갑을 복구해야 할 때 'inzect'는 유효한 영어 단어가 아니므로 'insect'를 사용해야 한다고 빠르게 결정할 수 있다. 이것은 HD 지갑을 관리할 때 시드를 어떻게 보관해야 하는가와 연결된 문제다. 데이터 손실(사고 혹은 도난)이 나서 지갑을 복구하려면 시드가 필요하므로 백업은 매우 중요하다. 그래서 시드는 디지털 백업보다는 종이에 써서 보관할 것을 추천한다.

요약하면, HD 지갑의 인코딩을 위한 복구 단어 목록을 사용하는 것이 오류 없이 고쳐 쓰고, 종이에 기록하고, 읽고, 안전하게 내보내고, 개인키들을 다른 지갑으로 가져오는 가장 쉬운 방법이다.

## **2. 지갑의 모범 사례**

암호화폐 지갑 기술이 성숙해짐에 따라 광범위하게 상호운용할 수 있고, 사용하기 쉽고, 안전하고, 유연한 지갑을 만들기 위한 일반적인 산업 표준이 등장했다. 또한 이러한 표준을 통해 지갑은 단일 니모닉에서 여러 개의 서로 다른 암호화폐에 대한 키를 파생시킬 수 있다. 이러한 일반적인 표준은 다음과 같다.

* BIP-39 기반 니모닉 코드 단어
* BIP-32 기반 HD 지갑
* BIP-43 기반 다목적(multipurpose) HD 지갑 구조
* BIP-44 기반 복수화폐(multicurrency) 및 복수계정(multiaccount) 지갑

이러한 표준은 향후 개발로 변경되거나 폐기될 수도 있지만, 현재 대부분의 블록체인 플랫폼과 암호화폐를 서로 연결해 주는 사실상의 기술적 지갑 표준으로 사용되고 있다.

이 표준은 소프트웨어 및 하드웨어 지갑에 광범위하게 채택되어 모든 지갑의 상호운용이 가능하게 되었다. 사용자는 이러한 지갑 중 하나에서 생성된 니모닉을 내보내고 다른 지갑으로 가져와서 모든 키와 주소를 복구할 수 있다. 이러한 표준을 지원하는 소프트웨어 지갑의 몇 가지 예로는 잭스(Jaxx), 메타마스크(MetaMask), 마이크립토(MyCrypto), 마이이더월렛(MyEtherWallet)이 있다. 이러한 표준을 지원하는 하드웨어 지갑의 예로는 킵키(Keepkey), 레저(Ledger) 및 트레저(Trezor)가 있다.

> 만약 이더리움 지갑을 구현하려면 BIP-32, BIP-39, BIP-43, BIP-44 표준을 따라 백업을 위해 니모닉 코드로 인코딩된 시드를 사용하여 HD 지갑을 구축해야 한다.

### **2-1. 니모닉 코드 단어(BIP-39)**

니모닉 코드 단어는 결정적 지갑을 파생하기 위해 시드로 사용되는 난수를 인코딩하는 단어 시퀀스다. 단어 시퀀스는 시드를 다시 만들어내고, 이 시드로부터 지갑과 모든 파생된 키들을 재생성할 수 있다. 니모닉 단어와 함께 결정적 지갑을 구현한 지갑 애플리케이션은 지갑을 처음 만들 때 12~24개의 단어 시퀀스를 보여줄 것이다. 단어 시퀀스는 지갑의 백업으로, 동일하거나 호환 가능한 지갑 애플리케이션에서 모든 키를 복구하고 다시 생성하는 데 사용할 수 있다. 앞서 설명했듯이, 니모닉 단어 목록을 사용하면 사용자가 쉽게 읽을 수 있고 정확하게 바꿔쓸 수 있으므로 지갑을 백업하기가 더 쉽다.

> 니모닉 단어를 '브레인월렛(brainwallet)'과 혼동하는데, 이들은 서로 같지 않다. 브레인월렛은 사용자가 고른 단어로 구성되는 반면, 니모닉 단어는 지갑이 무작위로 생성해서 사용자에게 보여준다는 것이 가장 큰 차이점이다. 이런 중요한 차이점은 니모닉 단어를 좀 더 안전하게 만든다. 왜냐하면 인간은 무작위성에 아주 약하기 때문이다. 아마도 더 중요하게는 '브레인월렛'이란 용어를 사용한다는 건 암기해야 한다는 것으로, 이는 아주 좋지 않은 아이디어일 뿐만 아니라 필요한 백업을 하지 않게 만드는 나쁜 방법이다.

니모닉 코드는 BIP-39에 정의되어 있다. BIP-39가 니모닉 코드 표준의 한 가지뿐임을 기억할 필요가 있다. 일렉트럼 비트코인(Electrum Bitcoin) 지갑에서 BIP-39 이전에 사용한 다른 단어 세트인 다른 표준도 있다. BIP-39는 트래저(Trezor) 하드웨어 지갑을 지원하는 회사가 제안했으며, 일렉트럼 구현과 호환되지 않는다. 그러나 BIP-39는 현재 수십 개의 상호운용이 가능한 구현으로 광범위하게 산업계 전반에 걸쳐 지원받고 있으며, 사실상 업계 표준으로 고려되어야 한다. 더욱이 BIP-39는 일렉트럼 시드와 달리 이더리움을 지원하는 복수화폐 지갑을 생산하는 데 사용할 수 있다.

BIP-39는 니모닉 코드와 시드의 생성을 정의하는데, 여기서는 아홉 단계로 설명한다. 명확하게 하기 위해 1~6단계, 7~9단계로 프로세스를 두 부분으로 나누어 볼 수 있다.

**니모닉 단어 생성**

니모닉 단어는 BIP-39에서 정의한 표준화된 절차에 따라 지갑에서 자동으로 생성된다. 지갑은 엔트로피의 원천에서 시작해서 체크섬을 추가하고 단어 목록에 엔트로피를 매핑한다.

1. 128~256비트의 무작위 암호화 시퀀스 S를 생성한다.
2. S를 SHA-256으로 해싱한 값을 32비트로 나눈 처음 길이를 체크섬으로 생성한다.
3. 무작위 시퀀스 S의 끝에 체크섬을 추가한다.
4. 시퀀스와 체크섬을 연결한 것을 11비트 단위로 나눈다.
5. 각각의 11비트 값을 사전에 정의된 2,048단어 사전과 매핑한다.
6. 단어의 시퀀스로부터 순서를 유지하면서 니모닉 코드를 생성한다.

[그림 5-2]는 엔트로피를 사용해서 어떻게 니모닉 단어를 생성하는지 보여준다.

**[그림 5-2] 엔트로피 생성과 니모닉 단어로 인코딩**



아래 표는 엔트로피 데이터 크기와 니모닉 코드 길이 간의 관계를 보여준다.

|엔트로피(비트)|체크섬(비트)|엔트로피 + 체크섬(비트)|니모닉 길이(단어)|
|:--:|:--:|:--:|:--:|
|128|4|132|12|
|160|5|165|15|
|192|6|198|18|
|224|7|231|21|
|256|8|264|24|

**니모닉에서 시드까지**

니모닉 단어는 128~256비트 길이의 엔트로피를 표현한다. 엔트로피는 키 스트레칭(key-stretching) 함수 PBKDF2를 사용하여 더 킨(512비트) 시드를 파생하는 데 사용되며, 생성된 시드는 결정론적 지갑을 구축하고 키를 파생하는 데 사용된다.

키 스트레칭 함수에는 니모닉과 `솔트(salt)`라는 두 가지 파라미터가 있다. 키 스트레칭 함수에서 솔트의 목적은 무차별 대입 공격을 가능하게 하는 조회 테이블(lookup table) 생성을 어렵게 하는 것이다. BIP-39 표준에서 솔트는 또 다른 목적을 갖는다. 솔트는 추가적인 보안 요소 역할을 하는 암호문 추가를 사용할 수 있게 해준다.

7단계부터 9단계까지 설명하는 절차는 앞 절에서 설명한 절차에서 이어진다.

7. PBKDF2 키 스트레칭 함수의 첫 번째 파라미터는 6단계에서 생성된 니모닉이다.
8. PBKDF2 키 스트레칭 함수의 두 번째 파라미터는 솔트이다. 솔트는 문자열 상수 "mnemonic"과 선택적으로 사용자가 지정한 암호문을 연결하여 구성한다.
9. PBKDF2는 최종 출력으로 512비트 값을 만드는 HMAC-SHA512 알고리즘으로, 2048 해시 라운드를 사용하여 니모닉과 솔트 파라미터를 확장하며, 이 결과로 나온 512비트 값이 시드다.

[그림 5-3]은 니모닉이 어떻게 시드를 생성하는지를 보여준다.

**[그림 5-3] 니모닉에서 시드까지**



> 키 스트레칭 함수는 2048 해시 라운드로 니모닉 또는 암호문에 대한 무차별 대입 공격을 다소 효과적으로 막아준다. 수천 개 이상의 암호와 니모닉 조합을 시도하는 데는 비용(계산)이 많이 든다. 가능한 파생 시드의 수(2^512, 즉 약 10^154)는 방대하고 가시적인 우주의 원자 수(약 10^80)보다 훨씬 크다.


