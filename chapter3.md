# **Chapter 3. 이더리움 클라이언트**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

## **1. 이더리움 클라이언트**

이더리움 클라이언트는 이더리움 사양을 구현하고 다른 이더리움 클라이언트와 피어투피어 네트워크를 통해 통신하는 소프트웨어 애플리케이션이다. 기준 사양과 표준 통신 프로토콜을 준수한다면, 서로 다른 이더리움 클라이언트들끼지 `상호운용(interoperate)`이 가능하다. 이러한 서로 다른 클라이언트가 다른 탐과 다른 프로그래밍 언어로 구현되는 동안 이들은 모두 동일한 프로토콜로 `소통(speak)`하고 동일한 규칙을 따른다. 따라서 이들은 모두 동일한 이더리움 네트워크에서 운영 및 상호작용하는데 사용될 수 있다.

이더리움은 오픈 소스 프로젝트이며, 모든 주요 클라이언트의 소스 코드는 오픈 소스 라이선스(예: LGPL v3.0)하에서 사용할 수 있으므로 무료로 다운로드하여 다른 용도로 자유롭게 사용할 수 있다. 오픈 소스란 단순히 자유롭게 사용할 수 있는 것 이상을 의미한다. 또한 이더리움은 공개 기여자 커뮤니티에 의해 개발되어 누구든지 수정할 수 있다. 참여자가 많을수록 신뢰할 수 있는 코드가 된다.

이더리움은 `황서`라는 공식 사양에 의해 정의된다.

하지만 비트코인은 이와 달리 공식적인 방식으로 정의되지 않는다. 비트코인의 사양이 비트코인 코어(Core) 기준 구현체인 반면, 이더리움은 영어와 수학(공식) 사양이 결합되어 문서화되어 있다. 이 공식 사양은 다양한 이더리움 개선 제안과 함께 이더리움 클라이언트의 표준 작동 방식을 정의한다. 황서는 이더리움에 주요 변경사항이 적용됨에 따라 주기적으로 업데이트 된다.

이더리움은 각 클라이언트가 구현해야 될 사양에 대해 명확한 기준을 제시하고 있기 때문에, 독립적으로 개발된 클라이언트들도 대부분 상호운용이 가능하다. 이더리움은 다른 블록체인보다 네트워크에서 실행되는 구현의 다양성이 더 크며, 이는 일반적으로 좋은 점으로 평가된다. 실제로 이더리움은 네트워크 공격을 방어하기 위한 훌륭한 방법으로 입증되었다. 왜냐하면 특정 클라이언트의 구현 전략을 악용하는 것은 개발자가 공격을 패치하는 동안 개발자를 괴롭히지만 다른 클라이언트는 네트워크에 거의 영향을 주지 않기 때문이다.

## **2. 이더리움 네트워크**

이더리움 기반 네트워크 중에는 이더리움 `황서`에서 정의된 공식 사양에 부합하지만, 서로 간에 상호운용될 수도 있고 그렇지 않을 수도 있는 것들이 많이 있다.

이더리움 기반 네트워크는 이더리움, 이더리움 클래식(Classic), 엘라(Ella), 익스팬스(Expanse), 유비크(Ubiq), 뮤지코인(Musicoin) 및 기타 여러 네트워크가 있다. 대부분 프로토콜 수준에서 호환되는 반면, 이더리움 클라이언트 소프트웨어의 관리자가 각 네트워크를 지원하기 위해 작은 변경을 요구하는 기능 또는 속성을 갖고 있는 경우가 많다. 이 때문에 이더리움 클라이언트 소프트웨어의 모든 버전이 모든 이더리움 기반 블록체인을 실행하는 것은 아니다.

현재 여섯 가지 언어로 작성된 이더리움 프로토콜의 여섯 가지 기본 구현이 있다.

* 러스트(Rust)로 작성된 패리티(Parity)
* 고(Go)로 작성된 게스(Geth)
* C++로 작성된 cpp-ethereum
* 파이썬(Python)으로 작성된 pyethereum
* 스칼라(Scala)로 작성된 맨티스(Mantis)
* 자바(Java)로 작성된 하모니(Harmony)

이번 장에서는 가장 일반적인 2개의 클라이언트인 패리티와 게스에 대해 살펴볼 것이다. 각 클라이언트를 사용하여 노드를 설정하고 커맨드 라인(command-line) 및 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API) 중 일부를 탐색하는 방법을 학습한다.

### **2-1. 풀 노드를 실행해야 하는가?**

블록체인의 건전성(health), 복원력(resilience), 검열 저장(censorship resistance) 특성은 독립적으로 운용되고 지리적으로 분산된 풀 노드(full node)가 얼마나 많은지에 달려있다. 각각의 풀 노드는 다른 새 노드가 블록 데이터를 얻어 작업을 부트스트랩(bootstrap)하고, 운영자에게 모든 트랜잭션 및 컨트랙트에 대해 신뢰할 수 있고 독립적인 검증을 제공할 수 있도록 도와준다.

그러나 풀 노드를 실행하면 하드웨어 자원 및 대역폭 비용이 발생한다. 풀 노드는 80 ~ 100GB 정도의 데이터를 다운로드해야 하며(2018년 9월 기준이며 클라이언트에 따라 다르다), 로컬 하드 디스크에 저장해야 한다. 새로운 트랜잭션 및 블록이 추가되면서 매일 이러한 데이터 부담이 상당히 빠르게 증가한다.

이더리움 개발에는 `메인넷(mainnet)` 네트워크에서 실행 중인 풀 노드가 필요하지 않다. `테스트넷(testnet)` 노드(작은 공개 테스트 블록체인 중 하나에 연결), 가나슈(Ganache) 같은 로컬 사설 블록체인 또는 인퓨라(Infura) 같은 서비스 공급자가 제공하는 클라우드 기반 이더리움 클라이언트로 원하는 대부분의 작업을 수행할 수 있다.

블록체인의 로컬 사본을 저장하지 않거나 블록 및 트랜잭션의 유효성을 확인하지 않는 원격 클라이언트를 실행할 수도 있다. 이 클라이언트는 지갑의 기능을 제공하며 트랜잭션을 생성하고 전파할 수 있다. 원격 클라이언트를 사용하여 자신의 풀 노드, 공개 블록체인, 공개 또는 허가된(권위증명(Proof-of-Authority)) 테스트넷 또는 개인 로컬 블록체인 같은 기존 네트워크에 연결할 수 있다. 실제로 다른 모든 노드 옵션 간에 전환하기 위한 편리한 방법으로 메타마스크(MetaMask), 에메랄드 지갑(Emerald Wallet), 마이이더월렛(MyEtherWallet), 마이크립토(MyCrypto) 같은 원격 클라이언트를 사용할 것이다.

