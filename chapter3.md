# **Chapter 3. 이더리움 클라이언트**
> 본 글은 『Mastering Ethereum』을 읽고 정리한 내용입니다.

## **1. 이더리움 클라이언트**

이더리움 클라이언트는 이더리움 사양을 구현하고 다른 이더리움 클라이언트와 피어투피어 네트워크를 통해 통신하는 소프트웨어 애플리케이션이다. 기준 사양과 표준 통신 프로토콜을 준수한다면, 서로 다른 이더리움 클라이언트들끼지 `상호운용(interoperate)`이 가능하다. 이러한 서로 다른 클라이언트가 다른 탐과 다른 프로그래밍 언어로 구현되는 동안 이들은 모두 동일한 프로토콜로 `소통(speak)`하고 동일한 규칙을 따른다. 따라서 이들은 모두 동일한 이더리움 네트워크에서 운영 및 상호작용하는데 사용될 수 있다.

이더리움은 오픈 소스 프로젝트이며, 모든 주요 클라이언트의 소스 코드는 오픈 소스 라이선스(예: LGPL v3.0)하에서 사용할 수 있으므로 무료로 다운로드하여 다른 용도로 자유롭게 사용할 수 있다. 오픈 소스란 단순히 자유롭게 사용할 수 있는 것 이상을 의미한다. 또한 이더리움은 공개 기여자 커뮤니티에 의해 개발되어 누구든지 수정할 수 있다. 참여자가 많을수록 신뢰할 수 있는 코드가 된다.

이더리움은 `황서`라는 공식 사양에 의해 정의된다.

하지만 비트코인은 이와 달리 공식적인 방식으로 정의되지 않는다. 비트코인의 사양이 비트코인 코어(Core) 기준 구현체인 반면, 이더리움은 영어와 수학(공식) 사양이 결합되어 문서화되어 있다. 이 공식 사양은 다양한 이더리움 개선 제안과 함께 이더리움 클라이언트의 표준 작동 방식을 정의한다. 황서는 이더리움에 주요 변경사항이 적용됨에 따라 주기적으로 업데이트 된다.

이더리움은 각 클라이언트가 구현해야 될 사양에 대해 명확한 기준을 제시하고 있기 때문에, 독립적으로 개발된 클라이언트들도 대부분 상호운용이 가능하다. 이더리움은 다른 블록체인보다 네트워크에서 실행되는 구현의 다양성이 더 크며, 이는 일반적으로 좋은 점으로 평가된다. 실제로 이더리움은 네트워크 공격을 방어하기 위한 훌륭한 방법으로 입증되었다. 왜냐하면 특정 클라이언트의 구현 전략을 악용하는 것은 개발자가 공격을 패치하는 동안 개발자를 괴롭히지만 다른 클라이언트는 네트워크에 거의 영향을 주지 않기 때문이다.

## **2. 이더리움 네트워크**

이더리움 기반 네트워크 중에는 이더리움 `황서`에서 정의된 공식 사양에 부합하지만, 서로 간에 상호운용될 수도 있고 그렇지 않을 수도 있는 것들이 많이 있다.

이더리움 기반 네트워크는 이더리움, 이더리움 클래식(Classic), 엘라(Ella), 익스팬스(Expanse), 유비크(Ubiq), 뮤지코인(Musicoin) 및 기타 여러 네트워크가 있다. 대부분 프로토콜 수준에서 호환되는 반면, 이더리움 클라이언트 소프트웨어의 관리자가 각 네트워크를 지원하기 위해 작은 변경을 요구하는 기능 또는 속성을 갖고 있는 경우가 많다. 이 때문에 이더리움 클라이언트 소프트웨어의 모든 버전이 모든 이더리움 기반 블록체인을 실행하는 것은 아니다.

현재 여섯 가지 언어로 작성된 이더리움 프로토콜의 여섯 가지 기본 구현이 있다.

* 러스트(Rust)로 작성된 패리티(Parity)
* 고(Go)로 작성된 게스(Geth)
* C++로 작성된 cpp-ethereum
* 파이썬(Python)으로 작성된 pyethereum
* 스칼라(Scala)로 작성된 맨티스(Mantis)
* 자바(Java)로 작성된 하모니(Harmony)

이번 장에서는 가장 일반적인 2개의 클라이언트인 패리티와 게스에 대해 살펴볼 것이다. 각 클라이언트를 사용하여 노드를 설정하고 커맨드 라인(command-line) 및 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API) 중 일부를 탐색하는 방법을 학습한다.

### **2-1. 풀 노드를 실행해야 하는가?**


